## 데이터 교환 형식 #1. JSON과 직렬화와 역직렬화 ★★★

- JSON과 직렬화와 역직렬화

  JSON이란?
  JSON(JavaScript Object Notation)은 Javascript 객체 문법으로 구조화된 데이터교환 형식, python, javascript, java 등 여러 언어에서 데이터 교환형식으로 쓰이며 객체문법 말고도 단순 배열, 문자열도 표현 가능

    1. Javscript 객체 문법

  키와 값으로 구성됨. {key: value}

  이미 존재하는 키를 중복 선언하면 나중에 선언한 해당 키에 대응한 값이 덮어쓰기 됩니다.

    1. 데이터 + 교환 방식
       데이터는 추상적인 아이디어에서부터 시작해 구체적인 측정에 이르기까지 다양한 의미로 쓰입니다. 실험, 조사, 관찰 등으로부터 얻은 사실이나 자료 등을 의미합니다.

    2. 여러 언어에서의 쓰임
       객체, 해시테이블, 딕셔너리 등으로 변환되어 쓰임
       ex) json in javascript = javascript object
       json in python = dictionary

  Json은 여러 언어와 플랫픔으로부터 독립적이다.

  json은 느슨한 타입이라 key가 같더라도 value의 타입이 달라도 에러가 발생하지는 않지만, 권하는 방법은 아니다.

  JSON의 타입

  javascript object와 유사하지만 undefined, 메서드 등을 포함하지 않는다.

    - 수(Number)
    - 문자열(String)
    - 참/거짓(Boolean)
    - 배열(Array)
    - 객체(Object)
    - null

  JSON 직렬화, 역직렬화

  직렬화란 외부의 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술이며 역직렬화는 반대를 의미

  JSON.parse() → 역직렬화

  JSON.stringify() → 직렬화

  JSON의 활용

  JSON은 프로그래밍 언어와 프레임워크 등에 독립적이므로, 서로 다른 시스템간에 데이터를 교환하기에 좋습니다. 주로 API의 반환 형태, 시스템을 구성하는 설정파일에 활용됩니다.

  ex) 업비트의 API

  ex) package.json

- XML 마크업 형태를 쓰는 데이터 교환 형식

  XML(Extensible Markup Language)은 마크업 형태를 쓰는 데이터 교환 형식입니다.

  마크업형식

    - 마크업은 태그 등을 이용하여 문서나 데이터의 구조를 나타내는 방법.(속성 부여도 가능)

  구성

    1. 프롤로그: 버전,인코딩
    2. 루트요소(단 하나만)
    3. 하위 요소들

  면접 빈출 문제

  HTML과 XML 차이?

    - HTML의 용도는 데이터를 표시 / XML은 데이터를 저장 및 전송
    - HTML에는 미리 정의된 태그가 있지만 사용자는 XML에서 고유한 태그를 만들고 정의 가능
    - XML은 대/소문자를 구분하지만 HTML은 구분하지 않습니다. <book> 대신 <Book>으로 태그를 작성하면 XML 구문 분석기에서 오류가 발생합니다.

  XML은 JSON보다 직렬화/역직렬화가 복잡하다.

  JSON과 비교했을 때 닫힌 태그가 계속해서 들어가기 때문에 JSON과 비교하면 무겁습니다.

  또한 Javascript Object로 변환하기 위해서 JSON보다는 더 많은 노력이 필요합니다.(JSON은 JSON.parse() 면 됩니다.)

  XML의 활용

  sitemap.xml로 활용

  SEO(서치 엔진 옵티마이저)

  사이트를 만들 때 sitemap.xml 제출을 권장한다. (데이터베이스와 상호작용하는 크롤링 봇이 잘 크롤링하기 위해)

- API 개념

  API(Application Programming Interface)
  는 둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법이자 컴퓨터 사이에 있는 중계 계층을 의미합니다.
  ex) 프로토콜, 메서드, 데이터타입 등이 정의된 중계계층

  참고로 API는 과거부터 발전되어온 용어로 라이브러리 및 프레임워크를 설명하는 명세서, 웹상에서 WEB API, WEB Socket API 등을 가리키는데 현재를 기준으로 API라고 할 때 보통 WEB API를 기준으로 설명합니다.

  컴퓨터와 컴퓨터 사이 데이터를 교환하는데 중간에 있기 때문에 API는 중계 계층이다.

  Interface

    - 인터페이스는 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면입니다. 이를 통해 해당 컴퓨터의 내부서버가 어떻게 구현되어 있는지는 상관없이 인터페이스를 통해 통신 등이 가능합니다.

  API의 장점

    1. 제공자는 서비스의 중요한 부분을 드러내지 않아도 됩니다. 예를 들어 DB 설계 구조나 드러내고 싶지 않은 데이터베이스의 테이블 정보, 서버의 상수값 등을 드러내지 않고 드러내고 싶은 부분만을 드러낼 수 있습니다.
    2. 사용자는 해당 서비스가 어떻게 구현되는지 알 필요 없이 필요한 정보만을 받을 수 있습니다.
    3. OPEN API의 경우 앱 개발 프로세스를 단순화 시키고 시간과 비용을 절약할 수 있다.(예: 네이버 로그인)
    4. 내부 프로세스가 수정됐을 때 api를 매번 수정하는 것이 아닌 api가 수정이 안되게 만들 수 있다. 이를 통해 내부 db, 서버의 로직이 변경이 되어도 매번 사용자가 앱을 업데이트하는 일은 줄어들 수 있다. ex) DB 튜닝
    5. 제공자는 데이터를 한곳에 모을 수 있다. 예를 들어, 해당 사이트에 방문하는 방문자, 어떤 특정한 것을 클릭하는 사용자에 대한 이벤트를 집계하고 싶을 때 해당 API를 만들고 해당 이벤트가 발생하면 해당 API를 호출하게 만들면 해당 데이터를 한 곳에 모을 수 있습니다.
       ex) yes24의 베스트 셀러, 검색페이지에서의 사용자 이벤트

  API의 종류

    - private: 내부적으로 사용된다. 주로 해시키를 하드코딩해두고 이를 기반으로 서버와 서버간의 통신합니다. 이는 비즈니스 파트너와도 사용될 수 있습니다. 비밀스럽게 해당 파트너와 해시키를 공유해 통신합니다.
    - public: 모든 사람이 사용할 수 있습니다. 많은 트래픽을 방지하기 위해 하루 요청 수의 제한, 계정 당 몇 개 등으로 관리합니다.

- 가상머신(virtual machine)

  전통적인 배포방식

    - 물리적인 컴퓨터 한 대에 하나의 OS를 깔고 여러 가지 프로그램을 설치하는 방식.계정을 나눠 여러명의 사용자가 이용할 수 있도록 할 수 있지만 어떤 프로그램을 설치했을 때 다른 앱에 영향을 미칩니다.

  가상화 배포방식

    - 가상머신을 기반으로 배포하는 것을 말합니다. 가상머신이란 컴퓨터의 하드웨어를 소프트웨어적으로 구현한 것을 말합니다.
      계정을 나누는 것이 아니라 한대의 컴퓨터를 가지고 여러 개의 OS를 구동할 수 있게 되며 CPU, RAM을 물리적으로 갈아끼는 것이 아니라 설정만으로 이를 수행할 수 있게 되었습니다.

  아예 OS를 따로 두는 것.
  이러한 가상화라는 기술 때문에 한대의 하드웨어로 여러명의 사용자들에게 독립적으로 클라우드 서비스를 할 수 있습니다.
  단점: 가상머신 위에 OS 일일이 설치해야함

- 오프프레미스와 온프레미스
    - 오프프레미스
        - 클라우드 서비스는 내가 아닌 다른 회사의 공급자가 호스팅하고 인터넷을 통해 사용자에게 제공되는 인프라, 플랫폼 또는 소프트웨어를 말합니다.
          이를 이용하면 자체 인프라나 하드웨어 설치 없이도 애플리케이션과 리소스에 쉽고 싸게 이용이 가능합니다.
    - 온프레미스
        - 네트워크 선까는 것부터 시작해 서버, 데이터베이스 설치 등을 하는 것.
- IaaS와 PaaS와 SaaS
    - IaaS
        - Infrastructure as a service는 인프라형 클라우드 서비스입니다.
          클라우드가 단지 인프라를 제공합니다. node.js, MongoDB 등을 개발자가 직접 설치해야 하는 대신 특정 서비스에 종속되지 않습니다.
          ex) AWS EC2, NCP 등
        - 마치 빈 방을 주는 것과 같다!
    - PaaS
        - Platform as a service는 플랫폼형 클라우드 서비스 입니다.
          클라우드가 플랫폼을 제공합니다. Node.js, MongoDB 등이 설치되어 있으며 그저 클릭을 통해 해당 서비스를 이용할 수 있습니다. 모니터링, CI/CD가 제공됩니다.
          ex) heroku
        - 마치 빌트인 가전제품이 들어간 방을 주는 것과 같다!
    - SaaS
        - Software as a service 는 서비스형 클라우드서비스 입니다.
          완전한 서비스를 클라우드서비스로부터 제공받아 사용합니다.
          ex) 구글DOCS

  면접 빈출문제: Iaas와 PaaS의 차이
  → IaaS는 인프라만 제공하기 때문에 이식성이 높아서 다른 인프라로 옮기기 수월하다.(유연성이 더 높음)
  그러나, 운영비효율에서 PaaS가 이미 제공되는 기능들이 많아서 하나하나 구현해야 하는 IaaS보다 운영비효율이 높다.

- 컨테이너(container)와 도커(docker)
    - 컨테이너
        - 컨테이너는 애플리케이션이 한 컴퓨팅 환경에서 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 코드와 모든 종속성을 패키징하는 소프트웨어의 표준 단위입니다.
          컨테이너는 OS를 공유하기 때문에 빠르고, 경량화되어 있으며 격리성도 훌륭합니다. 그러나 OS에 문제가 생기면 다른 앱에도 영향을 미칠 수 있습니다.
        - OS를 공유하기 때문에 하이퍼바이저 가상화 방식의 OS를 하나하나 설치해주던 방식과는 차이점이 있다.
    - 도커
        - 도커는 컨테이너배포에 필요한 거의 모든 기능을 제공하는 플랫폼
        - 이식성, 유연성, 운영효율성 모두 갖춘 것이 도커 방식이다.

  도커의 과정

    1. 도커 파일: 패키지, 환경변수 설정 등을 기록한 파일입니다. 이를 빌드해 도커이미지로 변환합니다.
    2. 도커이미지: 컨테이너 실행에 필요한 파일과 설정값, 데이터 등을 포함된 상태값이며 불변합니다. 하나의 이미지에서 여러개의 컨테이너를 생성할 수 있으며 컨테이너의 상태와는 무관하게 이미지는 그대로 존재합니다.
    3. 도커컨테이너: 컨테이너가 실행시키면 도커이미지에 설정된 프로그램, 데이터 등이 실제 컴퓨팅 자원과 연결됩니다.

- CICD

  파이프라인

  코드구축부터 시작해서 배포까지의 일련 과정들을 CI/CD 파이프라인이라고 합니다.

  총 3가지의 단계로 구성됩니다.

    - continuous integration: 코드를 빌드하고 테스트하고 합칩니다.
    - continuous delivery: 해당 레포지토리에 릴리스합니다.
    - continuous deployment: 이를 프로덕션, 즉 실제 서비스에 배포합니다.

  충돌이라는 것은 대부분 일어나기 때문에 조금 더 작은 단위로 충돌이 일어나게 하는 것이 중요
  한달동안 코드를 짜서 배포하는게 아니라 작은 이슈 단위로 나눠서 보통 머지를 합니다.

  그렇다고 해서 너무 아토믹하게 작은 단위로는 하지는 않고 작은 issue단위로 머지를 하게 됩니다.

  만약 충돌시에는 서로 화면 공유하면서 합의하에 충돌을 해결하는게 제일 좋습니다.

- 클래스와 객체와 인스턴스의 차이
    - 클래스
        - 클래스란 객체를 만들어 내기 위한 틀이며 만들어 낼 객체의 속성과 메서드의 집합을 담아놓은 것
    - 객체
        - 객체란 클래스로부터 만들어지는 실체, 클래스로 선언된 변수를 객체라 한다.
    - 인스턴스
        - 인스턴스란 객체가 메모리에 할당이 된 상태이며 런타임에 구동되는 객체를 말합니다. 객체와 같은 의미로 쓰이기도 합니다.

  객체의 속성은 클래스가 같으면 같지만, 값은 다를 수 있다.

  Person a; //객체 생성

  new Person(”ada”, as); // 인스턴스화

- static 키워드는 왜 사용하며 단점은 무엇인가?

  static 키워드는 클래스의 인스턴스가 아닌 클래스에 속하며 클래스의 변수, 메소드 등을 공유하는데 사용됩니다. 이를 통해 해당 클래스로 만들어지는 객체사이에서 중복되는 메서드, 속성을 효율적으로 정의할 때 쓰입니다.
  → 메모리 효율성 증대시킬 수 있다.

  단점

  static은 선언하자마자 메모리에 올라가게 된다. 즉, 사용하지 않아도 메모리에 올라가게되서 메모리 낭비가 될 수 있다.

  static으로 선언하지 않은 변수는 heap에 할당되어 가비지 콜렉터가 메모리 관리를 하는데, static 선언된 변수는 프로그램이 종료될 때까지 회수가 되지 않는다. 메소드 area에 할당되기 때문에.→ 메모리 leak 발생.

- 오버로딩과 오버라이딩은 무엇인가요?
    - 오버로딩
        - 오버로딩은 이름이 같아도 매개변수 개수, 타입, 순서를 다르게해서 같은 이름으로도 여러 개의 함수를 정의할 수 있는 것을 말합니다. 이는 프로그램의 유연성을 높이고 결과적으로 코드를 깔끔하게 하는 효과가 있으며 같은 클래스 내에서 사용합니다.
    - 오버라이딩
        - 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 하는 것을 말합니다. 상속 관계 클래스에서 사용되며 static, final로 선언한 메소드는 오버라이딩이 불가능.

- 추상화란 무엇인가요?

  프로그래밍에서의 추상화는 복잡한 데이터, 구조, 시스템 등으로부터 핵심만을 가려내 덜 자세하게 만드는 것 또는 세부사항, 절차 등을 감추고 인터페이스 등을 만드는 것으로 복잡도를 낮추는 방법을 말합니다.

    - 데이터 추상화
        - 공통점을 모으고 차이점은 버립니다.
          예를 들어, 고양이, 강아지, 원숭이 등의 객체들의 공통적인 특징을 묶어 동물이라는 카테고리로 카테고리화 시킵니다.
    - 프로세스 추상화
        - 어떠한 내부 프로세스를 숨기는 것을 말합니다. 예를 들어 데이터베이스가 어떻게 데이터를 저장하는지 모르지만 단순하게 insert, upsert 등의 쿼리로 데이터를 저장할 수 있습니다.



- 컴파일러 언어와 인터프리터 언어의 차이가 무엇인가요?

  컴파일러와 인터프리터는 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어(0,1로 구성됨)로 변환하는 과정에 관여하는 프로그램입니다.

  컴파일러

    - 전체 변환: 소스 코드의 전체를 읽어 한 번에 기계어로 변환합니다. 변환 과정을 거친 후, 생성된 기계어 코드를 실행합니다.
    - 속도: 컴파일 과정 자체는 시간이 걸리지만, 변환된 코드는 직접 실행되므로 실행 시간은 빠릅니다.
    - 사용 예: C, C++, Rust, Go 등의 언어가 컴파일러를 사용합니다.
    - 코드를 수정했을 때 컴파일 과정이 필요합니다.

  인터프리터

    - 한 줄씩 변환: 소스 코드를 한 줄씩 읽어가며 바로 기계어로 변환하고 실행합니다.
    - 속도: 컴파일 단계가 없으므로 초기 시작은 빠르지만, 전체 코드 실행 시간은 컴파일러를 사용할 때보다 느릴 수 있습니다. 코드를 실행할 때마다 변환 과정을 거치기 때문입니다.
    - 사용 예: Python이 대표적으로 인터프리터 방식을 사용합니다.
    - 코드를 수정했을 때 컴파일 과정이 필요하지 않습니다.

  모두 고수준의 언어를 기계어로 변환한다는 공통점이 있다.

  JIT 컴파일러

  JIT 컴파일러는 인터프리터와 컴파일러의 중간 형태라고 볼 수 있습니다.

    - 코드 분석: 실행 시점에 프로그램 코드를 분석하여, 어떤 부분이 가장 자주 실행되는지 판단합니다.
    - 동적 컴파일: 분석 결과에 기반하여, 자주 실행되는 코드만을 선별적으로 기계어로 변환합니다. 이 과정은 프로그램 실행 중에 실시간으로 이루어집니다.
    - 최적화: 컴파일 과정에서 다양한 최적화 기법을 적용합니다.(가비지 컬렉션의 오버헤드 최소화)
    - 실행: 컴파일된 기계어 코드를 실행합니다. 프로그램이 계속 실행되면서 새로운 핫스팟이 발견되면, 해당 부분도 JIT 컴파일을 통해 최적화됩니다.

  ex) JVM(자바가상머신), .NET, V8(nodejs엔진)

  자주 사용되는 코드(hot code)의 실행 속도가 크게 향상되는 것이라는 장점과 컴파일 된 코드를 메모리에 저장해 캐싱하기 때문에 인터프리터 방식에 비해 더 많은 메모리를 소비한다는 단점이 있습니다.