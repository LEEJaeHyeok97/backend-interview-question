## 네트워크, 처리량, 트래픽, 대역폭, RTT ★★★

- 네트워크
    - 네트워크란 노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미
        - 노드: 서버, 라우터, 스위치 등 네트워크 장치
        - 링크(엣지): 유선 또는 무선과 같은 연결매체(와이파이나 LAN)

[www.naver.com](http://www.naver.com) 접속 시

Naver에 화면을 요청하면 화면을 받게 되는 것이다.

이때, 휴대폰과 응답을 받는 Naver가 Node가 된다.

노드를 잇는 매체가 링크가 된다.

- 트래픽
    - 특정시점에 링크 내의 ‘흐르는’ 데이터의 양을 말한다. 예를 들어 서버에 저장된 파일(문서, 이미지, 동영상 등)을 클라이언트가 다운로드 시 발생되는 데이터의 누적량을 뜻한다. 트래픽과 처리량을 헷갈릴 수 있는데
        - 트래픽이 많아졌다 = 흐르는 데이터가 많아졌다.
        - 처리량이 많아졌다 = 처리되는 트래픽이 많아졌다.

예를 들어 이미지나 동영상을 요청했을 때 서버에는 다음과 같은 트래픽이 발생하게 된다.

단위: bps(bits per sec)

Q1. 100KB 이미지를 1000명이 다운로드 시 누적 트래픽?

→ 100 * 1000 KB

- 처리량
    - 처리량(Throughput)은 링크 내에서 성공적으로 전달된 데이터의 양을 말하며 보통 얼만큼의 트래픽을 처리했는지 나타냅니다. 많은 트래픽을 처리한다. = 많은 처리량을 가진다.

단위: bps

처리량은 사용자들이 많이 접속할 때마다 커지는 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러, 장치의 하드웨어 스펙에 영향을 받습니다.

- 대역폭
    - 대역폭(bandwidth)은 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수를 말합니다.(최대 트래픽)
      예를 들어 고속도로의 차선이 2차선보다 8차선일 때 더욱 원활하게 교통이 이루어지듯이 대역폭이 높을수록 사용자에게 빠른 서비스를 제공 할 수 있습니다. 대략적인 최대동시 접속자 수 유추의 척도가 됩니다.
      단위: bps

- RTT
    - RTT(Round Trip Time: 왕복 지연 시간)는 신호를 전송하고 해당 신호의 수신확인에 걸린 시간을 더한 값이자 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간

## 네트워크 토폴로지: 버스, 스타, 트리 ★★★

- 네트워크 토폴로지
    - 네트워크 토폴로지란 노드(컴퓨터, 라우터, 스위치 등)와 링크(케이블, 무선)가 어떠한 구조로 연결되어 있는지를 나타내는 방식입니다. ex) 버스, 스타, 트리 토폴로지

버스 토폴로지

버스 토폴로지는 회선 하나에 여러 개의 노드가 연결된 구조입니다. 모든 노드는 이 주 회선을 통해 데이터를 송수신하며, 네트워크의 모든 통신은 이 하나의 회선을 통해 이루어집니다. 새로운 노드를 추가하거나 삭제하는 것이 쉽고, 설치비용 또한 적습니다. → 버스 하나만 사용하므로 유지보수 ↑

[참고] 하나의 중앙 통신 회선을 버스라고 부릅니다.

- 장점
    - 보통 소규모 네트워크에서 설치 되기 때문에 설치 비용이 적고, 간단한 구조라 복잡한 연결구조로부터 발생하는 문제점이 없어져 유지보수가 쉽습니다
    - 한 노드에 장애가 발생해도 전체 네트워크에 영향을 주지 않습니다.
- 단점
    - 회선에 많은 트래픽이 생기면 정체현상 발생가능성 높습니다.(패킷 손실 비율 높음)
    - 회선 하나로 운영되는 구조라 회선이 망가지면 모든 노드에 장애가 발생합니다.
    - 모든 노드가 동일 회선을 공유하기 때문에 패킷 도청(스니핑)이나 위조(스푸핑) 등의 보안 위협에 취약합니다.

스타 토폴로지

하나의 중앙 노드(허브 또는 스위치) 를 중심으로, 여러 개의 말단 노드가 별 모양처럼 각각 독립적으로 연결된 구조이며 모든 통신은 항상 중앙 노드를 통해서만 이루어집니다.

중앙 노드를 제외한 노드의 추가 및 삭제는 간단하며, 네트워크 전체에 영향을 주지 않습니다. 그러나 중앙 노드에서 장애가 발생하면 모든 노드 간의 통신이 일시적으로 완전히 중단될 수 있습니다.

트리 토폴로지

트리 토폴로지는 계층적 구조를 가진 네트워크 형태로, 트리 구조처럼 상위 노드와 하위 노드가 단계적으로 연결되어 있습니다.

버스 토폴로지와 스타 토폴로지의 형태를 결합해서 하이브리드 구조로 쓰이기도 합니다.

중간 계층이 에러가 발생하면 하위 노드들이 다 망가지게 되는 특징이 있다.

## 링, 메시 ★★★

- 링형 토폴로지
    - 링형 토폴로지란 노드들이 고리 형태로 연결된 네트워크 구조를 말합니다.

장점

- 토큰링 기반 프로토콜로 데이터를 전달합니다. 네트워크 상에는 단 하나의 토큰이 존재하고 토큰을 소유한 노드만 데이터 송신, 수신 권한을 가집니다. 이 때문에 다른 노드가 동시에 전송할 일이 전혀 없으므로 데이터 충돌 발생이 없다는 장점이 있습니다.

단점

- 모든 노드를 거쳐서 전송이 되기 때문에 여기에 따른 전송 시간이 든다.

- 메시 토폴로지
    - 메시 토폴로지는 모든 노드들이 직접 서로 연결되는 그물망 형태의 네트워크 구조를 말합니다.
        - Full Mesh: 모든 노드가 서로 1:1로 연결되어 있는 구조
        - Partial Mesh: 일부 노드만 연결되어 있는 구조

## 네트워크 토폴로지의 필요성과 병목현상 ★★★

- 토폴로지의 필요성
    - 토폴로지는 병목현상을 해결하는 척도가 된다
- 병목현상
    - 병목(bottleneck) 현상은 트래픽에 의해 데이터 흐름이 제한되는 상황을 말합니다.
      핫스팟이라고도 합니다.(네트워크 한정)

## 유니캐스트, 멀티캐스트, 브로드캐스트 ★★★

- 유니캐스트
    - 유니캐스트란 1:1 통신을 말합니다. 대표적으로 HTTP통신이 있습니다. 가장 일반적인 네트워크 전송 형태입니다.
- 멀티캐스트
    - 멀티캐스트는 1:N 통신을 말합니다. N이지만 모든 노드들에게 데이터를 전달하지는 않고 특정 그룹에게만 데이터를 전달합니다.
- 브로드캐스트
    - 브로드캐스트는 1:N 통신을 말합니다. 그룹이 아닌 연결되어 있는 모든 노드에게 데이터를 전달합니다. 예로는 ARP가 있습니다.

## 네트워크의 분류: LAN, MAN, WAN ★☆☆

네트워크는 LAN, MAN, WAN 순으로 분류됩니다. LAN이 가장 작은 단위, WAN이 가장 큰 단위이며, 보통은 반경, 속도의 크기를 기반으로 분류합니다.

그러나 개념적으로 이해해서 분류하는게 중요합니다.

LAN

Local Area Network - 근거리 통신망 / MAN, WAN보다 높은 안정성, 속도 / 소규모 네트워크(집, 사무실) - 보통 허브나 스위치로 연결됩니다.

<aside>

하나의 논리적 주소인 IP를 기반으로 여러개의 물리적 주소인 MAC 주소로 구별하는 네트워크라고도 볼 수 있음

</aside>

MAC주소 →물리적 주소(공장에서 받는 기기의 고유 번호)(변하지 않는다)

IP → 논리적 주소(변한다)

하나의 ip를 받아서 NAT를 통해 가상의 IP로 각 MAC주소로 데이터를 전송할 수 있다.

(내부적으로는 MAC주소로 결국 구분하게 된다)

- MAN
    - metropolitan area network, 대도시 통신망, 두 개이상의 LAN이 연결된 것이 MAN이다.

- WAN
    - wide area network, 인터넷도 WAN이다. 많은 라우터를 거쳐 다른 국가와도 연결된다.

## TCP/IP 4계층 개념, 캡슐화, 비캡슐화, PDU, OSI 7계층

TCP/IP 4계층은 장치들이 인터넷 상에서 데이터를 주고받을 때 쓰는 프로토콜의 집합입니다. 4개의 계층으로 나뉘어집니다.

[참고]

TCP/IP는 TCP = Transmission Control Protocol / IP(Internet Protocl)이라는 의미이며

인터넷에서 데이터를 전송할 때 가장 핵심적인 두 프로토콜이 바로 TCP와 IP이기 때문에 TCP/IP 라고 부릅니다.

프로토콜=컴퓨터 간 대화 방법을 정한 규칙

Application - SMTP, HTTP/HTTPS, FTP, SSH

Transport - TCP/UDP

- Application
    - 여기서 애플리케이션이란 우리가 평소에 사용하는 웹 브라우저, 이메일, 파일 전송 도구와 같은 사용자 UI를 가진 프로그램과 혼동하기 쉽지만, 그 프로그램이 네트워크와 통신할 수 있도록 도와주는 기능적인 계층을 말합니다.
      즉, 사용자가 웹사이트를 열거나 이메일을 보내는 등의 작업을 했을 때, 그 데이터를 어떻게 보내야 할지 결정하는 프로토콜이 모여 있는 계층입니다.
        - HTTP:

- 전송계층
    - TCP, UDP가 대표적이며 애플리케이션 계층에서 받은 메시지를 기반으로 세그먼트(TCP) 또는 데이터그램(UDP)으로 데이터를 쪼개고 데이터가 오류 없이 순서대로 전달되도록 도움을 주는 층입니다.
- 인터넷 계층(network)
    - IP, ICMP, ARP가 대표적이며 한 노드에서 다른 노드로 전송 계층에서 받은 세그먼트 또는 데이터그램을 패킷화 하여 목적지로 전송하는 역할을 담당합니다.
- 링크 계층(link)
    - 링크 계층은 전선, 광섬유, 무선 등으로 데이터가 네트워크를 통해 물리적으로 전송되는 방식을 정의합니다. 데이터링크 계층과 물리계층을 합친 계층입니다.

EX) TCP 통신을 한다고 생각하면

Message → 세그먼트화 → Transport계층에서 tcp header가 앞단에 추가

→ network 계층에서 packet 추가

→ link 계층에서 frame 정보들이 더 붙여지고

→ 비트화(0,1) 된다. → 데이터가 전송된다.

위 내용이 캡슐화다.

데이터를 받는 곳에서 다시 비캡슐화를 통해 받는 측에서는 데이터 하나만 받게된다.

- PDU
    - PDU(Protocol Data Unit)란 TCP/IP 4계층을 기반으로 설명했을 때 각 계층의 데이터 단위를 의미합니다.
        - 애플리케이션 계층: 메시지
        - 전송 계층: 세그먼트(TCP)/데이터그램(UDP)
        - 인터넷 계층: 패킷
        - 데이터링크 계층: 프레임
        - 물리 계층: 비트

참고로 모든 계층에 전달되는 데이터가 쪼개져서 ‘패킷’으로 전달된다고 하는 것도 맞는 말이나 PDU에 따라 부르는게 더 맞는 표현이다.

- 체크섬
    - 데이터를 전송할 때 오류가 발생했는지 확인하기 위해 붙이는 추가 데이터 조각

- 1의 보수합
    - 모든 데이터를 16비트 단위로 더한 후, 그 합의 1의 보수를 취해 체크섬으로 사용한다는 것. 수신 측은 데이터 + 체크섬의 합이 0xFFFF가 되는지 검사하여, 데이터가 손상되었는지 판별하는 알고리즘

- CRC: 순환 중복 검사는 원본 데이터에 0을 XOR 이진 검사를 수행하는 방식

## TCP/IP 4계층: MTU와 MSS와 PMTUD

앞서서 패킷이 쪼개져서 데이터를 송수신한다고 했죠?

패킷으로 쪼개질 때 MTU를 기반으로 쪼개집니다.

MTU(Maximum Transmission Unit)는 네트워크 통신할 때 할 수 있는 가장 큰 PDU의 크기를 말합니다.

ex) 터널의 높이제한을 생각

통신을 하는 양쪽 끝은 두 장치의 MTU만이 아니라 중간의 모든 라우터, 스위치, 서버를 고려해야 합니다. 네트워크 경로 상에 있는 아무 장치나 MTU보다 패킷이 크면 그 패킷은 분할될 수도 있습니다.

- 패킷이 분할되지 않는 경우
    - 패킷을 분할할 수 없어 네트워크 경로 상에 있는 어떠한 라우터나 장치의 MTU를 초과할 때 분할해서 전달하는 것이 아니라 전달을 아예 하지 않을 수도 있습니다.

- IPv6는 분할을 허용하지 않습니다.

- MTU와 MSS
    - MTU는 IP헤더와 TCP헤더의 크기까지 합치지만 MSS(Maximum Segment Size)는 TCP에서 사용할 수 있는 데이터의 크기이자 TCP 헤더, IP헤더를 뺀 크기를 말합니다.

- FCS은 데이터의 에러를 검출하기 위해 삽입되는 필드

- PMTUD
    - Path MTU Discovery 경로상에서 패킷을 누락한 경우 테스트 패킷의 크기를 낮추면서 MTU에 맞게끔 반복해서 보내는 과정을 말합니다.

## 애플리케이션 계층

- HTTP

HTTP는 처음에는 서버와 브라우저간에 데이터를 주고받기 위해 설계된 프로토콜입니다.

지금은 브라우저 뿐만 아니라 서버와 서버간의 통신에도 많이 사용됩니다.

1. HTTP는 헤더를 통한 확장이 쉽다.
    1. 예를 들어 헤더값에다가 어떠한 값을 넣어서 HTTP요청을 할 때 쉽게 다른 값을 추가할 수 있다.
2. HTTP는 stateless합니다.
    1. 동일한 연결에서 연속적으로 수행되는 두 요청 사이에 연속적인 상태값은 없습니다.

- SSH
    - SSH(Secure Shell Protocol)는 보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜입니다.
    - 로컬에서 코드를 aws로 전달할 때 사용

- FTP
    - File Transfer Protocl 는 노드와 노드 간 파일을 전송하는데 사용되는 프로토콜
    - ex) 파일질라

- SMTP
    - 보통 네이버에서 메일을 보낼 때 http가 아닌 smtp를 통해 메일을 보내게 된다.
      인터넷을 통해 메일을 보낼 때 사용되는 프로토콜 보통 서비스를 운영하면 메일링 서비스를 하게 되는데 node.js를 통해 메일을 보낸다면 이를 통해 보내야 합니다.

## 전송 계층 TCP와 UDP

- TCP
    - 가상회선 패킷 교환 방식
- 오류검사 매커니즘
    - 재전송: 시간 초과 기간이 지나면 서버는 전달되지 않은 데이터에 대해 재전송을 시도합니다.
    - 체크섬: 체크섬을 통해 무결성을 평가합니다. 즉, 송신된 데이터의 체크섬과 수신된 데이터의 체크섬 값을 비교해서 올바르게 왔는지를 확인
    - 신뢰성 O
    - 연결을 보장. 3way 핸드쉐이크로 연결을 맺고 4way 핸드쉐이크로 연결 해제
    - 브로드캐스트 지원X
    - 속도가 느림

TCP는 20~60바이트로 가변적이다.

- UDP
    - 데이터그램 패킷 교환 방식
    - 오류 검사는 단순히 체크섬만 지원
    - 8바이트로 고정 길이를 가진다
    - 신뢰성 X
    - 브로드캐스트 지원O
    - 속도가 빠름

## 인터넷 계층과 ICMP

- 인터넷 계층
    - IP, ICMP, ARP가 대표적이며 한 노드에서 다른 노드로 전송 계층에서 받은 세그먼트 또는 데이터그램을 패킷화하여 전송한다.
- ICMP
    - ICMP는 노드와 노드 사이에서 통신이 잘되나를 확인할 때 쓰는 프로토콜입니다.
      이는 데이터를 교환하는데 사용되지 않는 프로토콜입니다.
      일반적으로 테스팅에 사용된다. 독립적인 비연결형 프로토콜
    - ex) cmd의 ping 명령

## 3-웨이 핸드쉐이크

TCP의 연결 성립 과정

1. SYN 단계: 클라이언트는 서버에 클라이언트 ISN을 담아 SYN을 보냄
2. SYN + ACK 단계: 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN+1을 보냄
3. ACK 단계: 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보냄

*ISN: 통신에 고유한 번호를 붙여 충돌하지 않게끔 하는 고유 번호.
SYN할때마다 부여 받음

SYN: synchronization의 약자, 연결 요청 플래그

ACK: acknowledgement의 약자, 응답 플래그

## 4웨이 핸드쉐이크와 TIME_WAIT ★★★

1. 먼저 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보냅니다.
   그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다림.
2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보내고 close_wait 상태에 들어감. 클라이언트가
   세그먼트를 받으면 FIN_WAIT_2 상태에 들어감
3. 서버는 LAST_ACK 상태가 되며 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보냄
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 되며 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫힘

- TIME_WAIT
    - 지연 패킷이 발생했을 때 데이터 무결성을 해결하기 위함. 두 배의 세그먼트 수명 시간을 기다림.
      소켓이 바로 소멸되지 않고 일정 시간 유지되는 상태를 말하며 지연 패킷 등의 문제점을 해결하는 데 쓰임.ㅇ
      또한 연결을 올바르게 닫힌상태로 만들기 위해 존재. 예를 들어 CLOSED가 아닌 LAST_ACK로 되어 있으면 다음 연결 때 오류 발생.

## 라우팅 개념과 라우터

라우팅(routing)은 네트워크에서 데이터를 보낼 때 최적의 경로를 선택하는 과정이며 라우터가 이를 수행합니다. 데이터는 보통 출발지에서 목적지로 가는 동안 여러개의 라우터를 거치며 여러번의 라우팅을 수행합니다.(라우팅은 초당 수백만번 일어납니다.)

- 라우터
    - 라우터는 네트워크 사이에서 데이터를 전달하는 장치이며 보통 둘 이상의 서로 다른 네트워크에 연결됩니다. 데이터를 목적지로 보낼 때 최적의 경로를 결정하고 경로가 결정되면 해당 경로로 데이터를 넘겨주는 일을 수행합니다.
      라우터는 라우팅테이블을 기반으로 데이터를 다음 목적지에게 전달합니다.
      라

## 라우팅 테이블

- 라우팅 테이블
    - 라우팅 테이블은 IP 주소를 기반으로 라우터의 위치를 저장한 테이블 또는 데이터베이스 이며 다양한 네트워크에 대한 정보와 해당 네트워크에 연결하는 방법이 포함되어 있습니다.
- 라우팅 테이블의 구성요소
    - 네트워크 대상: 목적지 네트워크의 IP
    - 서브넷 마스크: 대상 주소를 설명할 때 쓰이는 값
    - 게이트웨이: 이 장치와 연결되어 있는 홉, 패킷이 전달되는 다음 ip주소 만약 목적지가 로컬 네트워크라면 ‘연결됨’라고 표기 되며 다른 네트워크라면 해당 네트워크의 게이트웨이를 기다립니다.
    - 인터페이스: 게이트웨이로 가기위해 거치는 장치
    - 메트릭: 패킷 전송을 위해서 최적의 경로가 선택되도록 참고되는 값. 메트릭은 일반적으로 홉 수가 들어가며 지연시간, 처리량 등이 들어갈 수 있다.

- 게이트웨이
    - 게이트웨이는 프로토콜 변환기라고도 불리며 네트워크와 네트워크를 잇는 장치이다. 라우터와 하는 기능자체가 비슷하다.

- 홉
    - 홉은 네트워크에서 출발지와 목적지 사이에 위치한 장치를 의미하며 홉 카운트는 데이터가 출발지와 목적지 사이에서 통과해야 하는 홉의 개수를 의미합니다.

*홉카운트는 적은게 좋다.

## IP주소, MAC주소, ARP, RARP

- IP주소 - 논리적이다= 변한다.

- MAC주소: 네트워크 인터페이스에 할당된 고유 식별자

참고로 MAC주소는 보통 유일하지만 실수 또는 고의적으로 중복되게 만들 수 있다. 또한 MAC주소를 변경할 수도 있다.

- ARP: IP를 통해 MAC주소를 찾을 때 사용한다.
- RARP: MAC주소를 통해 IP를 찾을 때 사용한다.

- ARP의 과정
    - 해당 IP주소에 맞는 MAC주소를 찾기 위해 해당 데이터를 ‘브로드캐스팅’을 통해 연결된 네트워크에 있는 모든 장치에 보낸다.
    - 맞는 장치가 있다면 해당 장치는 보낸 장치에게 유니캐스트로 데이터를 전달해 주소를 찾게 된다.

## IP주소체계: IPv4와 IPv6

- IPv4: 2^32 주소를 표현 가능. 32bit이기 때문.
    - Checksum  있음
- IPv6: 128비트로 표현되는 주소 체계. 2^128개의 주소를 표현가능.
    - Checksum 없음

Ipv6가 보통 IPv4보다 빠르다.IPSec도 있어서 보안적으로도 Ipv6가 더 좋다. 일부에서는 IPv6가 더 느린 경우도 존재하기도 한다.

## 클래스 풀

네트워크를 어떻게 구분할것인가? → 클래스 풀

IP주소는 인터넷 주소로 네트워크주소, 호스트주소 즉, 두 부분으로 나뉜다. 네트워크 주소는 호스트들을 모은 네트워크를 지칭. 네트워크 주소가 동일 = 로컬네트워크/호스트주소 : 호스트를 구분하기 위한 주소

- 정의
    - 네트워크 주소를 매기고 그에 따라 네트워크의 크기를 다르게 구분하여 클래스를 할당하는 주소체계 / 구분하는 기준자를 서브넷마스크라 함.

## 클래스리스와 서브넷마스크, 서브넷팅

클래스리스: 클래스로 나누는 것이 아니라 서브넷마스크를 중심으로 어디까지가 네트워크 주소고 어디까지가 호스트주소인지 나눈다.

- 서브네팅: 네트워크를 나눈다
- 서브넷: 쪼개진 네트워크
- 서브넷마스크: 서브네트워크를 위한 비트마스크

현재 저희의 주소체계는 클래스리스를 사용한다.

## 공인IP 와 사설 IP

IP주소의 부족을 공인IP와 사설IP로 나누고 중간에 NAT이라는 기술로 해결한다.

Network  Address Translation는 패킷이 트래픽 라우팅 장치를 통해 전송되는 동안 패킷의 IP주소를 변경, IP주소를 다른 IP 주소로 매핑하는 방법.

NAT를 통해 내부 네트워크 IP가 노출되지 않는다는점이 장점이다.

내부 장치들은 NAT를 통해 외부와 통신하게 함으로써 외부로 IP를 노출하지 않고 보안적으로 이점을 챙길 수 있는 것이다.

## HTTP 헤더

헤더는 key-value 형태로 설정된다.

- 일반 헤더
    - 요청한 URL, 요청 메서드, 해당 자원을 요청할 때 해당자원의 출처를 나타내는 URL을 노출시킬지 말지를 정하는 보안정도가 설정되어 있는 Referrer Policy 등이 들어간다.
- 요청헤더
    - 요청헤더는 클라이언트가 설정 또는 자동으로 설정되는 헤더를 말한다.

- 응답 헤더
    - 서버의 소프트웨어 정보가 담긴다. 해킹방지를 위해 자세한 내용은 담지 않는다.

HTTP 헤더자체가 굉장히 유연하게 설계되어 있어서 커스텀하게 만들 수 있지만

보통은 지정되어 있는 key값에 value를 담아서 설정. 예를 들어 쿠키를 설정할 때 요청헤더에는 Cookie라는 key에 응답헤더에 Set-Cookie라는 key에 쿠키를 담아 설정한다.

## HTTP/1.0과 HTTP/1.1의 차이와 keep-alive, HOL까지

HTTP/1.0

- 수명이 짧은 연결이라고 한다. HTTP요청은 자체 요청에서 완료가 된다. 각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되어있다. 한번 연결할 때마다 TCP연결을 계속해야 하니 RTT가 늘어나는 문제점이 있었다.

HTTP/1.1

- HTTP1.1은 HTTP/1.0의 단점을 보완한 프로토콜이다. 크게 3가지 장점이 있다

1. keep-alive default
    1. 매번 데이터를 요청할 때마다 TCP를 연결하는게 아니라 한번 연결해두고 계속해서 데이터를 받을 수 있게 만듬.이는 keep-alive 옵션을 기본옵션으로 하면서 가능해졌다.
2. 호스트 헤더
    1. HTTP/1.0은 서버가 하나의 호스트만 가진다고 생각하기 때문에 헤더에 호스트를 포함하지 않았다. 그러나 사실 서버는 여러개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경되었으며 항상 호스트를 포함해서 요청하도록 바뀌었다.
3. 대역폭 최적화
    1. HTTP/1.0에서 다운로드가 도중에 끊기면 이어받을 수 없었는데 HTTP/1.1부터는 되도록 발전했다.

- 이미지 스트라이프
    - 여러개의 이미지를 하나의 이미지로 만들어서 한번에 요청하는 것

- 이미지 64인코딩
    - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩해서 이미지 서버에 대한 http 요청을 할 필요가 없이 만드는 것을 말한다.
- HTTP/1.1의 고질적 문제 HOL
    - HOL(Head of LineBlocking)과 무거운 헤더를 가지는 문제점을 해결하지 못했다.
      네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능저하 현상

## HTTP/2와 HTTP/3의 차이

- HTTP/2: TCP기반, 멀티플렉싱으로 성능 향상
- HTTP/3: UDP 기반 QUIC 사용, 연결 성능 개선 + HOL 블로킹 제거 + 보안 내장

*멀티 플렉싱

- 한 연결로 여러 데이터를 동시에 주고받는 기술

*QUIC

- TCP보다 빠르고 끊겨도 빠르게 다시 연결됨

*HOL

- TCP는 순서를 지키려다보니 앞줄의 데이터가 막히면 뒤의 데이터도 못가는 현상

## HTTPS와 TLS

- HTTPS
    - HTTP + 보안 기능 추가된 버전
    - 데이터를 주고받을 때 암호화해서 도청이나 위조 방지
    - HTTP + TLS
- TLS
    - 데이터를 암호화하는 보안 프로토콜
    - 클라이언트와 서버 사이의 통신을 암호화
    - SSL이라고도 불렸지만 지금은 TLS가 표준

HTTPS = TLS로 암호화된 HTTP

## TLS 핸드셰이크

- HTTPS 같은 보안 통신에서 클라이언트와 서버가 안전한 통신을 시작하기 위한 절차.
  이 과정에서 암호화 방식 협상, 인증서 확인, 대칭키 생성 등이 일어난다.

1. Client Hello
    1. 서버로 다음 정보를 보냄
    - TLS 버전
    - 클라이언트가 지원하는 암호 스위트 목록 (암호화 알고리즘 조합)
    - 난수 (random)
    - 세션 ID (옵션)

1. Server Hello
    1. 응답
    - 선택한 암호 스위트
    - 서버의 인증서 (공개키 포함)
    - 난수 (random)
    - 세션 ID (옵션)

1. 서버 인증 및 키 교환
2. 양측은 이제 암호화된 통신을 시작하겠다고 선언