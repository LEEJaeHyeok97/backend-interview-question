- 디자인 패턴이란? ★★★

  디자인 패턴의 의미

    - 디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것을 의미합니다. 디자인 패턴은 라이브러리나 프레임워크를 만드는데 기초적인 원리가 되며 지금도 많은 라이브러리, 프레임워크가 어떠한 디자인 패턴을 기반으로 만들어지고 있습니다.

  ex) 전략패턴 → passport.js

    - 이점

  여러 문제 해결의 영감을 받을 수 있다.

  팀원과 협업할 때 빠른 의사소통이 가능하기도 하다.

    - 디자인 패턴의 종류
        - 디자인 패턴은 크게 생성 패턴, 구조 패턴, 행동 패턴 3가지로 나눠진다.

    1. 생성 패턴: 객체를 어떻게 만들까?에 대한 것
        1. 생성 패턴은 객체 생성 방법이 들어간 디자인 패턴입니다.
           **싱글톤, 팩토리**, 추상팩토리, 빌더, 프로토타입 패턴이 있습니다.
    2. 구조 패턴
        1. 구조 패턴은 객체, 클래스 등으로 큰 구조를 만들 때 유연하고 효율적으로 만드는 방법이 들어간
           디자인 패턴입니다.
           **프록시**, 어댑터, 브리지, 복합체, 데코레이터, 퍼사드, 프라이웨이트 패턴이 있습니다.
    3. 행동 패턴: 문제에 대한 답이 담긴 패턴
        1. 객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴입니다.
           **이터레이터, 옵저버, 전략**, 책임연쇄, 커맨드, 중재자, 메멘토, 상태, 템플릿메소드, 비지터 패턴이 있습니다.

  이 외에도 수 많은 패턴이 존재한다.

- 라이브러리와 프레임워크의 차이 ★★★
    - 라이브러리
        - 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것이며 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유롭습니다.
          ex) 차 / axios
    - 프레임워크
        - 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 말합니다. 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격합니다.
          ex) 비행기 / vue.js, 장고

  라이브러리는 프레임워크 안에 넣을 수 있다.

  ex) axios라는 라이브러리를 vue.js와 react.js에 들어가 있다.

- 싱글톤 패턴

  싱글톤 패턴(Singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다. 하나의 클래스를 기반으로 여러 개의 개별적인 인스턴스를 만들 수 있지만 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는데 쓰이며 보통 데이터베이스 연결모듈에 많이 사용합니다.

    - 장점
        - 하나의 인스턴스를 기반으로 해당 인스턴스를 다른 모듈들이 공유하여 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듭니다. 그렇기 때문에 “인스턴스 생성에 많은 비용”이 드는 I/O 바운드 작업에 많이 사용합니다.
    - 단점
        - 의존성이 높아지며 TDD를 할 때 걸림돌이 됩니다. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 합니다.
          하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기가 어렵습니다.


    *I/O바운드: 디스크 연결, 네트워크 통신, 데이터베이스 연결

- 싱글톤 패턴을 구현하는 7가지 방법 #1
    1. 단순한 메소드 호출
        1. 싱글톤 패턴 생성 여부를 확인하고 싱글톤이 없으면 새로 만들고 있다면 만들어진 인스턴스를 반환합니다.
           그러나 이 코드는 메서드의 원자성이 결여되었습니다. 멀티스레드 환경에서는 싱글톤 인스턴스를 2개 만들 수 있습니다.

        ```java
        public class Singleton {
        		private static Singleton instance;
        		
        		private Singleton() {
        		
        		}
        		
        		public static Singleton getInstance() {
        				if (instance == null) {
        						instance = new Singleton();
        				}
        				return instance;
        		}
        }
        ```

       자바는 멀티 스레드 언어이다.

       Thread 1이 객체를 만든 후 Thread2도 만약 동시에 객체를 만든다면 thread-safe 하지 않다.

       자바에서는 이런 환경을 고려해야 한다.

        1. Synchronized

       이를 해결하기 위해 synchronized 키워드를 메소드에 추가해주면 해결된다.

       → 다른 스레드가 접근하지 못하도록 lock을 걸기 때문에 성능이 저하된다.

        1. 정적 멤버

       정적(static) 멤버나 블록은 런타임이 아니라 최초에 JVM이 클래스 로딩 때 모든 클래스들을 로드할 때 미리 인스턴스를 생성하는데 이를 이용한 방법입니다.

       클래스 로딩과 동시에 싱글톤 인스턴스를 만듭니다. 그렇기 때문에 모듈들이 싱글톤 인스턴스를 요청할 때 그냥 만들어진 인스턴스를 반환하면 됩니다.

       이는 불필요한 자원낭비라는 문제점이 있습니다. 싱글톤 인스턴스가 필요 없는 경우도 무조건 싱글톤 클래스를 호출해 인스턴스를 만들어야 하기 때문입니다.

        1. 정적 블록

       정적(static) 블록을 사용해도 된다.

        ```java
        public class Singleton {
        		private static Singleton instance;
        		
        		private Singleton() {
        		
        		}
        		
        		static {
        				instance = new Singleton();
        		}
        }
        ```

- 싱글톤 패턴을 구현하는 7가지 방법 #2
    1. 정적 멤버와 Lazy Holder(중첩 클래스)

  singleInstanceHolder라는 내부클래스를 하나 더 만듬으로써, Singleton클래스가 최초에 로딩되더라도 함께 초기화되지 않고 getInstance()가 호출될 때 singleInstanceHolder 클래스가 로딩되어 인스턴스를 생성하게 된다.

    ```java
    class Singleton {
    		private static class singletonInstanceHolder {
    				private static final Singleton INSTANCE = new Singleton();
    		}
    		public satic Singleton getInstance();
    }
    ```

    1. 이중 확인 잠금(DCL)

  이중 확인 잠금도 있습니다. 인스턴스 생성 여부를 싱글톤 패턴 잠금 전에 한번. 객체를 생성하기 전에 한 번 2번 체크하면 인스턴스가 존재하지 않을 때만 잠금을 걸 수 있기 때문에 앞서 생겼던 문제점을 해결하 수 있습니다.

  volatile? -

  자바에서는 스레드 2개가 열리면 변수를 메인 메모리에서 가져오는게 아니라 캐시 메모리에서 각각의 캐시메모리를 기반으로 가져오게 된다.

  volatile을 하게되면 캐시메모리가 아니라 메인 메모리로부터 변수를 공유하게 된다.

    1. enum

  enum의 인스턴스는 기본적으로 스레드세이프한 점이 보장되기 때문에 이를 통해 생성할 수 있다.

  그래서 최고의 방법은?

  5번과 7번을 추천한다. 5번은 가장 많이 쓰인다고 알려져 있고, 7번은 이펙티브 자바를 쓴 조슈아 블로크가 추천한 방법이다.

- 팩토리 패턴 ★★★

  팩토리 패턴이란 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.

  상위 클래스에서는 객체 생성방식에 대해 알 필요가 없어져 유연성을 갖게되고 객체 생성 로직은 하위 클래스에서만 관리 되기 때문에 유지보수성이 증가됩니다.

- 이터레이터 패턴

  이터레이터 패턴은 iterator를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴입니다. 각기 다른 자료구조들을 똑같은 인터페이스로 순회를 쉽게할 수 있다는 장점이 있습니다. 컨테이너란 동일한 요소들을 담아놓는 집합을 말합니다. 배열, 맵 등이 있습니다.

- DI와 DIP

  의존성 주입(Dependency Injection)이란 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이부분을 가로채 메인 모듈이 ‘간접’적으로 의존성을 주입하는 방식입니다.

  의존관계 역전 원칙(DIP)

    - 의존성 주입을 할 때는 의존관계역전원칙이 적용됩니다.
      이는 2가지의 규칙을 지키는 상태를 말합니다.
        - 상위 모듈은 하위 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.
        - 추상화는 세부사항에 의존해서는 안된다. 세부사항은 추상화에 따라 달라져야 한다.

  의존성 주입의 장점

    - 외부에서 모듈을 생성하여 집어넣는 구조가 되기 때문에 모듈들을 쉽게 교체할 수 있다.
    - 단위 테스팅과 마이그레이션이 쉬워진다.
    - 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기 쉬워진다.
- 전략 패턴(행동 패턴)

  전략패턴이란 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴입니다.

  ex) 인프런 로그인 시 다양한 로그인 방법을 통해 로그인을 할 수 있다.

  이렇게 각기 다른 전략을 로그인이라는 Context(행위, 상태)를 쉽게 교체하도록 하는게 전략 패턴이다.

    ```java
    interface PaymentStrategy {
    		public void pay(int amount);
    }
    
    class KAKAOCardStrategy implements PaymentStartegy {
    		private String name;
    		...
    		
    		public KAKAOCardStrategy(String name, ...) {
    				this.name = name;
    				...
    		}
    
    }
    
    public class ShoppingCart() {
    		public void pay(PaymentStrategy paymentMethod) {
    				int amount = calculateTotal();
    				paymentMethod.pay(amount);
    		}
    }
    
    public class HelloWorld {
    		public static void main(String []args) {
    				..
    				Shopping cart = new ShoppingCart();
    				cart.pay(new KAKAOCardStartegy("Ju hongchul", "", ...);
    }
    ```

  위와 같이 [car.pay](http://car.pay) 메소드 안에 캡슐화 해서 전략이 들어가는 것이 전략 패턴이다.

- 옵저버 패턴(행동 패턴)

  옵저버 패턴이란 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.

  트위터의 메인 로직, 그리고 MVC 패턴에도 적용되었습니다.

  주체가 subject가 되는 경우도 있다.

- 프록시 패턴(구조 패턴)

  프록시 패턴이란 객체가 어떤 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채서 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴입니다.

  ex)

  Cloudflare가 프록시 서버 역할을 하여 디도스 트래픽을 필터링 할 수 있다.

- MVC 패턴과 MVP패턴 그리고 MVVM 패턴
    - MVC 패턴
        - MVC 패턴은 model, view, controller로 이루어진 디자인 패턴입니다.

  모델

  모델은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다.
  뷰에서 데이터를 생성하거나 수정할 때 컨트롤러를 통해 모델이 생성 또는 업데이트 됩니다.
  예를 들어 사용자가 네모박스에 글자를 적는다고 해보죠. 이 때 모델은 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷 정보 등이 됩니다.

  뷰
  뷰는 inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타내며 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 변경이 일어나면 컨트롤러에 이를 전달해야 합니다.

  컨트롤러

  컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다. 또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줍니다.

  MVC 패턴의 장점

    1. 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다.
    2. 재사용성과 확장성이 용이하다는 장점이 있다.

  MVC 패턴의 단점

  애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.

  MVC패턴을 반영한 대표적인 프레임워크로 Spring Web MVC가 있습니다.

  MVP 패턴

  C가 Presenter로 교체된 패턴. V와 P는 1:1 관계이므로 MVC보다 더 강력한 결합을 지닌 디자인 패턴입니다.

  MVVM 패턴

  MVC의 C가 VM(뷰 모델)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM: V = 1: N 이라는 관계를 갖는다.

  VM은 커맨드와 데이터바인딩을 가진다.

    - 커맨드: 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 방법
    - 데이터바인딩: 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법.

  EX) MVVM 패턴을 가진 대표적인 프레임워크는 뷰(Vue.js)가 있다.

  차이 정리

  | 특징 | MVC 패턴 | MVP 패턴 | MVVM 패턴 |
      | --- | --- | --- | --- |
  | 관계 | 컨트롤러와 뷰는 1:N | 프레젠터와 뷰는 1:1 | 뷰모델과 뷰는 1:N |
  | 참조 | 뷰는 컨트롤러 참조 x | 뷰는 프레젠터를 참조 o | 뷰는 뷰모델을 참조 o |
- Spring 의 MVC패턴 적용 사례

  디스패처 서블릿의 요청 처리과정

  Request → Dispatcher Servlet →

    1. 클라이언트가 요청을 했을 때 가장 먼저 디스패처 서블릿이 이를 받습니다.(프론트 컨트롤러 역할) 이 때 url 이나 form data를 기반으로 보통 @RequestMapping을 참고해서 특정 컨트롤러에 매핑한다.
    2. 하나 이상의 handler mapping을 참조해서 적절한 컨트롤러를 설정한다. 이후 컨트롤러로 요청을 보낸다.
    3. 컨트롤러는 데이터베이스에 접근하여 데이터를 가져오는 등 비즈니스로직을 수행한다.
    4. 그렇게 해서 사용자에게 전달해야 할 정보인 모델을 생성한다.
    5. 그 다음 뷰를 구현하기 위한 view resolver를 참고한다.

- flux 패턴

  flux 패턴은 단방향으로 데이터 흐름을 관리하는 디자인 패턴이다.

  Action → Dispatcher → Store → View

  ex) redux는 flux 패턴이 적용되서 만들어졌다.

- 전략 패턴과 의존성 주입의 차이는?

  의존성 주입이나 전략패턴 모두 무언가를 쉽게 교체하기 위한 디자인 패턴이라는 공통점이 있습니다. 그러나 다음과 같은 차이가 있습니다.

    - 전략 패턴: 어떠한 동일한 행동 계약을 기반으로 다양한 구현이 명시되어 있는 인터페이스를 만드는 것을 포함합니다.
    - 의존성 주입: 단지 일부 동작을 구현하고 의존성을 주입하기만 하는 패턴입니다.

  전략 패턴은 어떤 행위를 기반으로 하지만 의존성 주입은 단순히 주입한다는 개념이다.

- 컨텍스트란?
    1. 어떤 종류의 상태, 환경을 캡슐화한 것을 말함
    2. 작업이 중단되고 나중에 같은 지점에서 계속 될 수 있도록 저장하는 최소 데이터 집합.(컨텍스트 스위칭)

  ex) 프론트엔드에서 context를 통해 서로 다른 api에서 path를 공유하여 일일이 전달하지 않고 바로 사용할 수 있다.