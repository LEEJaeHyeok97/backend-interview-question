## 웹브라우저 캐시 1. 로컬스토리지의 개념과 실습

로컬 스토리지는 웹 스토리지 객체로 브라우저 내에 {key: value} 형태로 오리진에 종속되어 저장되는 데이터를 말합니다.

- 하나의 키에 오로지 하나의 값만 저장됩니다.
- 데이터는 사용자가 브라우저에서 수동으로 삭제하지 않는 한 평생 동안 로컬 저장소에 저장되며 만료날짜가 없습니다. 사용자가 창이나 탭을 닫아도, 컴퓨터를 종료해도 만료되지 않습니다.
- 최대 저장용량은 5MB입니다.
- 보통 사용자의 행위를 기억할 때, 로그인을 유지하기 위한 값 등으로 사용되며 로컬 스토리지 데이터는 자동으로 서버로 전송되지 않습니다.(쿠키는 자동 전송됨)

### 사용법

- 설정: localStorage.setItem(key, value);
- 탐색: localStorage.getItem(key);
- 제거: localStorage.removeItem(key);
- 전체제거: localStorage.clear();

## 로컬 스토리지와 오리진(origin)

로컬스토리지는 웹 스토리지 객체로 브라우저 내에서 key-value 형태로 오리진에 종속되어 저장되는 데이터를 말합니다. (오리진이 같은 브라우저 내에서 공유됩니다.)

오리진이란?

→ protocol(http, https)  + hostname + port

[ww.naver.com](http://ww.naver.com) 은 https와 https의 포트번호인 443은 생략될 수 있다.

(http의 기본 포트는 80)

## 로컬스토리지의 활용사례 - 캐싱

- 자동완성?
    - 이전에 입력한 값들이 쭉 나오는 것.(다시 입력할 가능성이 높다.)
      유저가 다시 입력할 수고를 덜 수 있다.

## 세션 스토리지

세션 스토리지는 로컬 스토리지와 매우 유사합니다.

세션 스토리지는 웹 스토리지 객체로 브라우저 내에 key-value 형태로 오리진에 종속되어 저장되는 데이터입니다.

다만, 동일한 오리진이라도 브라우저의 각 탭마다 독립적으로 저장됩니다. 즉, 다른 탭에서 세션 스토리지에 저장된 데이터에 접근할 수 없습니다.

- 하나의 키에 오로지 하나의 값만 저장된다.
- 최대 저장용량은 5MB
- 사용자가 브라우저를 닫으면 데이터는 만료된다.

### 세션스토리지 사용법

- 설정: sessionStorage.setItem(key, value);

## 쿠키(Cookie)

쿠키는 브라우저에 저장된 데이터 조각이다.

서버에서 응답헤더로 Set-Cookie로 설정해서 쿠키를 보내면 그 때 부터 클라이언트에서 요청헤더 Cookie에 설정되어 자동으로 서버에 전달되게 되고 브라우저에도 저장되게 됩니다.

- HTTP 헤더를 통해 클라이언트 또는 서버가 HTTP 요청 또는 응답 할 때 추가 정보를 전달할 수 있습니다.

쿠키는 클라이언트와 서버 둘 다 조작가능 하지만 보통 서버에서 만료기한 등을 설정 및 컨트롤을 함. 저장용량은 최대 4kb까지 가능합니다.

보통 로그인, 장바구니, 사용자 커스터마이징, 사용자 행동분석(주로 개인화된 광고에 활용되는 것들)에 사용됩니다.

### 클라이언트에서도 설정가능한 쿠키

클라이언트에서도 쿠키를 설정하고 보낼 수 있지만, 이를 권장하지 않는다.

쿠키에 대한 제어권을 클라이언트에게 두게 되는데 쿠키에는 보통 민감한 정보들이 담길 수 있으므로 이 제어권에 관한 것을 클라이언트가 아닌 서버가 두게 만들어야 한다.

### 세션 쿠키

세션 쿠키는 Expires 또는 Max-Age 속성을 지정하지 않은 것을 말합니다. 브라우저가 종료되면 쿠키도 사라집니다.

### 영구 쿠키

영구 쿠키는 Expires 또는 Max-Age 속성을 지정해서 특정날짜 또는 일정기간이 지나면 삭제되게 만든 쿠키 브라우저를 닫을 때도 만료되지 않습니다.

- secure
    - 쿠키에 이 옵션을 추가하면 https로만 쿠키를 주고받을 수 있습니다.
      하지만 Chrome v89 및 Firefox v75이상부터 localhost에서는 이 사양을 무시합니다.
      즉, localhost에서는 secure 옵션을 걸어도 http로 쿠키를 주고받을 수 있어 쉽게 테스팅이 가능합니다.

- httpOnly
    - 공격자가 쿠키를 자바스크립트로 빼낼 수 없게 만든다.
- sameSite
    - 요청이 동일한 도메인에서 시작된 경우에만 쿠키가 애플리케이션으로 전송되도록 허용

### 쿠키의 시큐어 코딩

쿠키 - 세션으로 로그인을 처리한다면 다음과 같은 시큐어 코딩을 해야합니다.

1. cookie에 세션ID를 담을 때 이 세션ID기반으로 클라이언트의 개인정보를 유추할 수 없게 해야합니다.
2. 자바스크립트로는 파악할 수 없게 http Only 옵션을 걸고 https로만 쿠키를 주고받을 수 있게 secure 옵션을 걸어야 합니다.
3. 일정시간의 세션 타임아웃을 걸어야 합니다.

### 쿠키허용관련 알림창

서비스 운용 시 쿠키를 사용한다면 쿠키허용관련 알림창을 만들어야 합니다. 방문 기록을 추적할 때 쿠키가 사용되기 때문입니다. 이는 사용자의 데이터 간접수집에 해당하며 거기에 해당하는 KISA 지침을 준수해야 합니다.

## 로컬스토리지, 세션스토리지, 쿠키의 공통점과 차이점

- 공통점
    - 브라우저에 캐싱을 함으로써 서버에 대한 요청을 줄여 서버부하를 방지할 수 있습니다.
    - 캐싱으로 인해 다운로드 하는 컨텐츠가 줄어들어 웹사이트의 컨텐츠를 더 빨리 다운로드 가능합니다.
    - 사이트 기본 설정 커스터마이징(색상, 글꼴 크기 등)을 저장하거나 로그인 상태를 유지할 때 사용될 수 있습니다.

### 차이점

|  | 쿠키 | 로컬 스토리지 | 세션 스토리지 |
| --- | --- | --- | --- |
| 최대 저장 용량 | 4KB | 5MB | 5MB |
| 브라우저 허용 | HTML4 + 5 | HTML 5 | HTML5 |
| 접근 범위 | 오리진 | 오리진 | 탭 |
| 만료 기한 | 수동으로 설정 | 영구적 | 탭 닫으면 소멸 |
| 설정할 수 있는 존재 | 클라이언트 + 서버 | 클라이언트 | 클라이언트 |
| 요청과 함께 서버에
자동전송 유무 | O | X | X |

쿠키와 로컬 스토리지는 브라우저 창을 닫아도 유지, 세션 스토리지는 삭제

## 세션기반 인증 방식 - 개념

로그인은 세션 기반 인증방식 vs 토큰 기반 인증 방식으로 구현된다.

HTTP 특징 중 하나는 stateless 하다는 것인데, 즉, HTTP 요청을 통해 데이터를 주고받을 때 요청이 끝나면 요청한 사용자의 정보 등을 유지하지 않는 특징이 있습니다.

이렇기 때문에 로그인 상태를 어떻게 유지하느냐?에 대한 질문이 생깁니다. 로그인은 이전에 로그인한 상태값이 남아 있어야 합니다.

예를 들어 로그인을 했는데 또 로그인을 해야 하는 서비스가 있다면 누구도 그 서비스를 이용하지 않을 것입니다.

- 세션: 서버와 클라이언트의 연결이 활성화된 상태를 의미합니다.
- 세션ID: 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크한 ID값

1. 클라이언트가 서버로 로그인 요청
2. 서버는 세션 ID를 생성 후 Set-Cookie로 클라이언트에 세션ID(굉장히 어려운 문자열로 이루어짐) 전달
3. 클라이언트는 쿠키가 설정되면 요청마다 쿠키의 헤더값에 세션ID가 부여되서 요청하게 된다.
4. 서버는 세션ID가 유효한지 검증 후 로그인 상태값을 클라이언트로 전달한다.

쿠키 & 세션의 단점

→ DB에 저장한다고 가정 시 직렬화 / 역직렬화 cost가 든다는 단점이 있다.

→ 서버 저장시에도 서버의 메모리가 소모된다.

## 토큰 기반 인증 방식(access 토큰, refresh 토큰) 개념

JWT란?

JSON WEB TOKEN을 의미하며 헤더, 페이로드, 서명으로 이루어져 있으며 JSON 객체로 인코딩되며 메시지 인증, 암호화에 사용됩니다.

- Header
    - 토큰 유형과 서명 알고리즘, base64URL로 인코딩 됩니다.
- Payload
    - 데이터, 토큰 발급자, 토큰 유효기간, base64URL로 인코딩 됩니다.
    - 이곳에도 민감한 정보는 넣지 말아야 한다.
- Signature
    - (인코딩된 header + payload) + 비밀키를 기반으로 헤더에 명시된 알고리즘으로 다시 생성한 서명 값.

### 장점

1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없다.
2. 다른 유형의 토큰과 비교했을 때 경량회되어 있습니다. SAML이란 토큰이 있지만 이에 비해 훨씬 경량화 되어 있다.
3. 디코딩했을 때, JSON이 나오기 때문에 JSON을 기반으로 쉽게 직렬화, 역직렬화가 가능하다.

### 단점

1. 토큰이 비대해질 경우 당연히 서버 과부하에 영향을 줄 수 있다.
2. 토큰을 탈취당했을 때 디코딩 시 데이터를 볼 수 있다.
    1. 가장 신경써야 하는 단점

## 토큰 기반 인증 방식 - 실습

토큰 기반 인증 방식에서는 refresh 토큰과 access 토큰 두개를 기반으로 구현합니다.

access 토큰은 수명을 짧게, refresh 토큰은 길게 합니다.

refresh 토큰은 access 토큰이 만료됬을 때, 다시 access 토큰을 발급하기 위해 사용되는 토큰입니다.

이를 통해 access 토큰이 만료됐을 때 마다 인증에 관한 비용이 줄어들게 됩니다.

로그인을 하게 되면 access토큰과 refresh 토큰 두개를 얻습니다.

그 다음 access 토큰이 만료되거나 사용자가 새로고침을 할 때, refresh 토큰을 기반으로 새로운 access Token을 얻습니다.

### 주의할 점

이렇게 access 토큰을 얻었다면 그 이후 요청할 때는 http header 의 쿠키나 authorization에 담아 요청을 하게 되는데, 다음과 같은 규칙을 지키는 것이 좋다.

- Bearer <token>으로 bearer을 앞에 둬서 토큰 기반 인증 방식이라는 것을 알려줘야 한다.
- https를 사용해야 한다.
- 쿠키에 저장한다면 sameSite:Strict을 써야 한다.
- 수명이 짧은 access Token을 발급해야 한다.
- url에 토큰을 전달하지 말아야 한다.

## HTTP 상태 코드(status code)

- 1xx(정보)
    - 서버가 요청을 잘 받았으며, 해당 프로세스를 계속 이어가며 처리하는 것을 의미
        - 100: 계속함을 의미합니다.
- 2xx(성공)
    - 서버가 요청을 잘 받았고 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미합니다.
        - 200 OK: 요청이 성공
        - 201 Created: 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었다.
- 3xx(리다이렉션)
    - 서버가 클라이언트의 요청에 대해 완료를 위해 추가 작업 조치가 필요합니다.
        - 301 Moved Permanently: 이 응답코드는 요청한 리소스의 URI가 변경되었음을 의미.
          새로 변경된 URI를 301 상태코드와 함께 주어야 한다.
- 4xx(클라이언트 오류)
    - 400 Bad Request: 서버가 클라이언트 요청을 이해할 수 없음
    - 401 UnAuthorized: 클라이언트의 인증이 되지 않음을 의미
    - 404 Not Found: 요청받은 컨텐츠를 찾을 수 없다는 것을 의미
- 5xx(서버 오류)
    - 서버가 클라이언트의 요청을 처리하지 못하는 상태
        - 500 Internal Server Error: 서버에 오류가 있음
        - 502 Bad Gateway: 게이트웨이 또는 프록시서버가 오류가 생김
        - 504 Gateway Timeout: 게이트웨이 또는 프록시서버가 정해진 Timeout 시간 동안 클라이언트의 요청을 처리하지 못함을 의미

## HTTP 메서드. GET 과 POST 차이

- GET
    - url을 기반으로 하기 때문에 길이 제한(2000자 미만)이 있습니다.
    - 성공시 HTTP 상태코드 200을 반환합니다.
    - 캐싱이 가능합니다.
    - URL을 기반으로 요청하기 때문에 해당 요청의 파라미터가 브라우저기록에 남습니다.
    - url을 기반으로 요청하기 때문에 ASCII문자열만을 보낼 수 있습니다.
    - 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않습니다.

- POST
    - URL이 아닌 HTTP message body를 통해 데이터를 전달합니다.
    - HTTP message body를 통해 전달되기 때문에 길이 제한이 없습니다.
    - 성공적으로 데이터를 생성할 경우 HTTP 상태코드 201을 반환합니다.
    - 캐싱이 불가능합니다.
    - url을 기반으로 요청하지 않기 때문에 해당 요청의 파라미터가 브라우저기록에 남지 않습니다.

## HTTP 메서드. PUT과 PATCH의 차이

둘 다 데이터를 수정할 때 쓰는 메소드이다.

- PUT: 업데이트하는 데이터의 전체를 보낸다.
    - 요청을 보낼 때 해당 데이터 전체를 보내야 하고 전체 데이터의 교체를 의미한다.
      또한, PUT은 만약 해당 데이터가 없다면 새로이 생성하고 있다면 해당 데이터가 있다면 요청할 때 보낸 데이터와 교체를 진행합니다.
- PATCH: 업데이트하는 데이터의 일부를 보내다.
    - 요청을 보낼 때 수정하는 일부분만 보내면 되고 일부분의 교체를 의미한다.

## 네트워크를 이루는 장치의 이해

### 레이어별 네트워크 장치

- 애플리케이션 계층: L7 스위치(로드 밸런서)
- 전송계층: L4 스위치
- 네트워크 계층: 라우터, L3스위치
- 데이터 링크 계층: L2스위치, 브리지
- 물리 계층: 리피터, NIC, AP

윗 단계 장치가 아랫단계 장치의 기능을 수행할 수도 있지만 역은 불가능하다.

## 네트워크를 이루는 장치 - 애플리케이션 계층

### L7 스위치

L7 스위치는 로드밸런서라고도 하며, 서버 부하를 분산하는 기기이다. 서버이중화, 보안에 강점이 있는 장치.

IP, Port뿐만 아니라 url, 헤더, 쿠키 등을 기반으로 트래픽을 분산합니다. 헬스체크를 통해 장애가 발생한 서버를 확인하고 해당 서버로 트래픽을 보내지 못하게 하는 역할을 합니다.

L7 → ALB

L4 → NLB

## 네트워크를 이루는 장치 - 전송 계층

### L4 스위치

앞서 설명한 로드밸런서의 특징인 트래픽 분산 등을 할 수 있습니다. 패킷의 IP주소와 Port번호를 참고해서 적절히 트래픽을 분산할 수 있습니다.

또한 전송계층의 TCP, UDP 등의 헤더를 기반으로 우선순위를 판단해서 분산이 가능합니다.

L7와 똑같이 헬스체크가 가능합니다.

## 네트워크를 이루는 장치 - 인터넷 계층(네트워크 계층)

### 라우터

라우팅은 하나 이상의 네트워크에서 경로를 선택하는 프로세스를 말하는데 이 라우팅을 하는 장비를 말합니다. 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 “패킷 소모 최소화”, “경로 최적화” 하는 장비입니다.

### L3 스위치

L2 스위치 기능 + 라우팅 장비. 라우팅 테이블을 참조해 IP패킷에 IP를 담아 보냅니다.

## 네트워크를 이루는 장치 - 데이터링크 계층

앞서 TCP계층을 설명할 때 데이터링크 계층과 물리 계층을 합해서 링크 계층으로 설명.

이 링크 계층은 데이터링크 계층과 물리 계층으로 나뉜다.

- 데이터 링크 계층은 ‘이더넷 프레임’을 통해 에러 확인, 흐름 제어, 접근 제어를 담당하는 계층
- 물리 계층은 무선 LAN과 유선LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층을 말함

### L2 스위치

L2스위치는 장치들의 MAC주소를 MAC 주소 테이블을 통해 관리하며 해당 테이블을 기반으로 인터넷 계층에서 받은 패킷을 기반으로 이더넷 프레임을 만들어 목적지MAC주소로 패킷을 보내주는 역할

L3와 L2 스위치의 차이?

→ L3: 라우팅 테이블, IP주소, IP패킷

→ L2: MAC 주소 테이블, MAC주소, 이더넷프레임

### 브리지

브리지는 두 개의 근거리 통신망을 상호 접속할 수 있도록 하는 통신망 연결 장치.

서로 다른 LAN으로 하나의 통신망을 구축할 때 사용.

## 네트워크를 이루는 장치 - 물리 계층

### NIC

LAN 카드라고 하는 네트워크 인터페이스 카드는 네트워크에 연결하기 위해 PC에 설치된 회로 기판을 말한다. 이 장치에는 PC 고유의 식별번호인 MAC주소가 있다.

### 리피터

약해진 신호를 증폭하는 장치

### AP

access point는 패킷을 복사하는 장치. AP에 유선LAN을 연결한 후 무선 LAN기술을 기반으로 무선 네트워크망을 구축할 수 있습니다.

## 유선 LAN - 전이중화 통신, CSMA/CD

전이중화(full duplex) 통신은 양쪽 장치가 동시에 송수신할 수 있는 방식을 말합니다.

동축케이블, 광케이블 등을 기반으로 만들어진 유선LAN을 이루는 이더넷은 IEEE802.3 프로토콜을 기반으로 전이중화 통신을 씁니다.

### 전이중화 통신

양쪽 장치가 동시에 송수신할 수 있는 방식, 송신로와 수신로를 나눠서 데이터를 주고받을 수 있다.

### CSMA/CD

이전에는 유선 LAN에 ‘반이중화 통신’ 중 하나인 CSMA/CD 방식을 썼습니다.

이 방식은 회선을 사용하는지 파악 후 사용하지 않는다면 데이터를 보내고 충돌이 발생한다면 일정 시간 후에 재전송하는 방식을 말합니다.

## 유선 LAN - 케이블

### 트위스트페어케이블

- 실드처리 한 케이블이 STP
- 안한 케이블이 UTP

### LAN 케이블

유선 LAN을 구축할 때 쓰는 케이블인 LAN 케이블은 UTP케이블 타입

### 광섬유 케이블

레이저를 통해 통신하는 케이블

코어+클레딩

## 무선 LAN - 반 이중화 통신, CSMA/CA, 와이파이

무선랜은 IEEE802.11을 따르고 반이중화 통신을 사용합니다.

### 반이중화 통신

양쪽 장치는 서로 통신을 할 수 있지만, 동시에는 통신할 수 없는 방식.

(하나의 회선만 사용)

- CSMA/CA

### 무선LAN의 대표적인 기술

와이파이 - 전자기기들이 무선 LAN 신호에 연결할 수 있게 하는 기술.

무선망에는 블루투스, 지그비 등도 있기 때문에 와이파이만 존재한다고 하면 틀린 말이다.

## 무선 LAN - 주파수와 2.4GHz와 5GHz의 차이

비유도 매체인 공기에 주파수를 쏘아 무선 통신망을 구축하는데, 주파수 대역은 2.4GHz 대역 또는 5GHz 대역 중 하나를 써서 구축한다.

- 2.4GHz
    - 호환성 좋음
    - 속도는 느림
    - 장애물이 있어도 잘 됨
- 5GHz
    - 호환성 낮음
    - 속도 빠름
    - 장애물 있으면 잘 안됨

## 대규모 트래픽으로 인한 서버 과부하 해결방법 1

### 서버 과부하의 의미

서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할 때 발생합니다. 이 때 서버는 사용자의 웹요청을 처리하지 못해 응답없음이 뜨게 됩니다.

실제로 LCK 결승전이라는 트래픽이 많이 몰리는 이벤트가 있습니다.

### 모니터링을 통한 자원 할당

서버가 응답 없음이 뜨는 것은 여러가지 이유가 있지만, 그 중 하나가 바로 “자원의 한계점 도달”입니다. 보통 서버의 CPU 사용량이 80-90%에 도달하거나 메모리가 부족해서 스와핑이 발생하면 과부하 상태가 됩니다.

- 스와핑은 운영체제 시간때 배움

이는 모니터링을 통한 자원의 적절한 할당으로 해결한다. 자원은 CPU, 메모리, 대역폭도 포함한다.

### AWS 오토스케일링

Threshold

memory 점유율등이 임계치를 넘으면 알림을 주는 방식으로 모니터링한다.

### 모니터링을 왜 할까?

먼저 서버 과부하로 인한 조치를 하기 위해서는

1. 어떤 페이지에 어떤 트래픽이 얼마나 발생했느냐.
2. 어떤 네트워크에서 병목현상이 일어 났느냐. 등을 기준으로 해결할 수 있습니다.
    1. 또한 모니터링을 하면 활용도가 낮은 페이지, 높은 페이지를 파악할 수 있어 나중에 서비스 개선에도 도움이 됩니다.

즉, 문제점을 파악하기 위해 모니터링은 필수적입니다.

Cloud Flare - CDN

### 로드밸런서

aws 오토스케일링이 빠르긴 하나 구성에 시간이 걸리기 때문에 앞단에 로드밸런서를 통해 트래픽을 분산해야 한다.

### 블랙스완 프로토콜

블랙스완이란? 예측할 수 없는 사고가 발생한 것을 말한다. 사후에는 이 사고의 원인 등을 분석할 수 있지만 사고전에는 예측할 수 없는 것을 의미한다.

1. 영향을 받은 시스템과 각 시스템의 상대적 위험 수준을 확인
    1. 체계적으로 데이터를 수집하고 원인에 대한 가설을 수립후 이를 테스팅
2. 잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락
3. 최대한 빨리 취약점에 영향을 받는 모든 시스템을 업데이트
4. 복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달

## 대규모 트래픽으로 인한 서버 과부화 해결방법 - 2

### 서킷 브레이커

서킷 브레이커 패턴이라고도 불리며 서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법이다.

서비스와 서비스 사이에 서킷브레이커 계층을 두고 미리 설정해 놓은 timeout 임계값에 도달하면 서킷브레이커가 그 이후의 추가호출에 무조건 에러를 반환하게 합니다.

(연쇄적인 오류 전파를 끝내는 서킷브레이커)

사용자 입장에서 응답을 오래 기다려야 하는 것은 좋은 UX가 아니다. 성공인지 실패인지는 중요하지 않다. 중요한 것은 사용자가 오래 기다리지 않아야 한다는 것이다.

유저 관점에서 더 괜찮은 선택

빠른 에러 리턴 > 기다리게 하기

### 서킷 브레이커 상태

서킷 브레이커는 closed, open, half_open의 상태값을 가진다.

- closed[정상]: 네트워크 요청의 실패율이 임계치보다 낮음
- open[에러]: 임계치 이상의 상태. 요청을 바로 서비스로 전송하지 않고 바로 오류를 반환한다. 이를 fail fast라고 한다.
- half_open[확인중]: open 상태에서 일정 timeout 으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위해 half_open 상태로 전환된다. 장애가 풀리면 closed, 실패하면 다시 open으로 변경

### 서킷브레이커의 장점

연속적인 에러 발생을 막아주며 일부서비스가 종료되더라도 다른 서비스들은 이상없이 동작하게 만들 수 있으며 사용자 경험을 높여 줍니다.

### 서킷브레이커가 구현된 라이브러리

서킷브레이커가 구현된 라이브러리로는 넷플릭스의 Hystrix와 Resilience4j가 대표적이다.

## 대규모 트래픽으로 인한 서버 과부화 해결방법 - 3

### 1. 불필요 컨텐츠 삭제

- 조회 쿼리 개선
    - 인덱스를 추가하거나 쿼리를 변경해서 인덱스를 사용하도록 개선
    - 개선이 안되는 쿼리라면 차라리 기능 OFF
- Select *로 조회되던 컬럼에서 고용량인 강의 소개 컬럼은 모두 제거
    - 실제 기능에서 사용되지 않던 컬럼

### CDN을 통한 컨텐츠 제공

CDN을 통해 사용자 가까이, 그리고 분산된 대규모 서버 네트워크를 기반으로 컨텐츠를 제공해서 메인 서버에 대한 부하를 줄인다.

이미지나 고정된 css나 html 등이 있다면 이런 정적 자원들(변하지 않는 자원들)은 메인 서버가 주는게 아니라

CDN이라는 분산된 서버를 이용해서 자원을 준다면 메인 서버의 비용을 줄일 수 있다.

좀 더 많은 트래픽을 메인 서버가 감당할 수 있게 된다.

### 컨텐츠 캐싱

네트워크 트래픽을 해결하는 가장 좋은 방법은 해당 트래픽이 발생하지 않도록 하는 것이다.

브라우저 캐시(쿠키, 로컬저장소, 세션저장소)를 통해 해당 요청에 관한 항목을 캐시에서 읽어서 응답을 읽어 네트워크 요청에 관한 비용을 모두 제거한다.

### 컨텐츠 압축

텍스트 기반 리소스는 gzip 또는 Brotli를 통해 압축해야 한다. 압축하면 70% 정도까지 압축할 수 있다. 다만 압축했기 때문에 압축을 풀기위해 서버에서 자원(CPU)를 사용하는 양까지 고려해야한다. 보통은 압축하면 좋다.

### 컨텐츠의 우아한 저하(미리 준비된 응답)

시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능을 일시적으로 줄이는 전략.

예를 들어 정적 텍스트 페이지를 제공하거나, 검색을 비활성화하거나 더 적은 수의 검색 결과를 반환하거나, 필수적이지 않은 기능을 비활성화 합니다.

## REST API란 무엇인가요?

REST API란 RESTful한 API를 말하며 일련의 특징과 규칙 등을 지키는 API를 일컫습니다.

### REST API의 특징

1.Uniform-Inteface

API에서 자원들은 각각의 독립적인 인터페이스를 가지며 각각의 자원들이 URL 자원 식별, 표현을 통한 자원 조작, Self-descriptive messages, HATEOAS 구조를 가지는 것

- url 자원 식별
    - 자원은 url로 식별되어야 한다.
- 표현을 통한 자원 조작
    - 메소드 + URL
- Self-descriptive message
    - http header에 타입을 명시
- Hateoas 구조

### Stateless

HTTP 자체가 Stateless하다.

세션기반 로그인 방식은 Restful 하지 않은 방식이다.

### Cacheable

HTTP는 원래 캐싱이 된다. 아무런 로직을 구현하지 않더라도 자동적으로 캐싱이된다.

이는 HTTP 메서드 중 GET에 한정되며 Cache-Control:max-age=100 이런 식으로 한정된 시간을 정할 수 있고 캐싱된 데이터가 유효한지 판단하기 위한 값도 존재한다.

### Layered System

계층 구조로 나뉘어 있는 아키텍처를 뜻함.

Rest api의 uri규칙

1. 동작은 HTTP메소드로만 해야하고 url에 해당 내용이 들어가면 안된다.
2. 확장자는 표시하지 않는다.
3. 동사가 아닌 명사로만 표기해야 한다.
4. 계층적인 내용을담고 있어야한다.
5. 대문자가 아닌 소문자로만 쓰며 너무 길 경우 언더바가 아닌 바를 쓴다.
6. HTTP 응답 코드를 적재적소에 사용한다.

[참고] api를 설정할 때 /v2 /v1 으로 버전을 명시해 놓는게 좋다. 이를 통해 현재 버전을 사용하다가 새 버전이 안정되면 자체적으로 마이그레이션할 수 있다.

## 브라우저 렌더링이란 무엇인가요?

### DOM 트리와 CSSOM트리

하나의 HTML 페이지는 div, span 등의 요소를 가지겠죠? 이러한 요소들이 HTML파서에 의해 “구문분석”됩니다.

CSSOM트리

### 렌더트리

display:none → 아예 요소에서 사라짐

visibility:none → 보이지 않지만 요소는 있음

DOM트리 구축

CSSOM트리 구축

렌더 트리와 렌더레이어 생성

렌더레이어를 대상으로 레이아웃 설정

렌더레이어를 대상으로 칠하기

레이어 합치기 및 표기

## wwwn.naver.com을 쳤을 때 생기는 과정, 그리고 DNS까지 설명해주세요

개발자는 과정을 이해해야 하는 사람.

1. 네이버입력
2. 리다이렉트
3. 캐싱

### 리다이렉트

리다이렉트가 있다면 리다이렉트를 진행하고 없다면 그대로 해당 요청에 대한 과정이 진행된다.

### 캐싱

해당 요청이 캐싱이 가능한지 가능하지 않은지 파악한다. 캐싱이 이미 된 요청이라면 캐싱된 값을 반환하며 캐싱이 되지 않은 새로운 요청이라면 그 다음 단계로 넘어갑니다. 이는 브라우저 캐시와 공유캐시로 나눠집니다.

- 브라우저 캐시
    - 쿠키, 로컬스토리지 등을 포함한 캐시. 개인 캐시라고도 합니다.
- 공유 캐시
    - 클라이언트와 서버 사이에 있으며 사용자간에 공유할 수 있는 응답을 저장할 수 있다.
      대표적인 예로 요청한 서버 앞단에 프록시 서버가 캐싱을 하는 것을 말한다.
    - ex) cloudfront, cloudflare 등

### DNS

DNS는 계층적인 도메인 구조와 분산된 데이터베이스를 이용한 시스템으로 FQDN을 인터넷 프로토콜인 IP로 바꿔주는 시스템입니다.

*FQDN: 호스트+도메인

### DNS 캐싱

도메인 주소의 실제 ip주소를 캐싱

### IP라우팅 & ARP

해당 IP를 기반으로 라우팅, ARP 과정을 거쳐 실제 서버를 찾음.

### TCP 연결

TCP 연결은 HTTP/2까지 일어납니다.

HTTP/3는 TCP연결이 아닌 QUIC연결이 일어납니다.

브라우저가 TCP 3웨이 - 핸드셰이크 및 SSL 연결 등을 통해 연결을 설정합니다. 이후 요청을 보낸 후 드디어 해당 요청한 서버로부터 응답을 받습니다.

### 다운로드

요청한컨텐츠를 서버로부터 다운받습니다.

### 브라우저 렌더링

받은 데이터를 바탕으로 브라우저 엔진이 브라우저 렌더링 과정을 거쳐 화면을 만듭니다.

## 이더넷 프레임은 무엇이며 구조가 어떻게 되나요?

이더넷 프레임이란 데이터 링크계층의 데이터 단위

## CORS란 무엇인가요?

sop을 좀 더 유연하게 만들어서 어떠한 경우에는 다른 오리진끼리도 요청 및 응답할 수 있게 만든게 cors

### cors의 의미

cross origin resource sharing란 http 헤더를 기반으로 브라우저가 다른 오리진에 대한 리소스로드를 허용할지 말지에 대한 매커니즘을 말한다.

### preflight request와 simple request

과정

만약 요청을 보낼 때 다음의 메서드타입(get, post), 헤더에 해당되지 않은게 하나라도 포함되어 있다면 preflight request를 보내게 된다. 반대로 모두 해당 타입, 헤더를 모두 가진 요청을 simple request이자 안전한 요청이라고 합니다.

## 네이글 알고리즘

네이글 알고리즘은 네트워크의 효율성을 높이기 위해 네트워크를 통해 전송해야하는 패킷 수를 줄이고 적은 양의 데이터를 자주 보내면 발생되는 대역폭 낭비를 막아주는 방법입니다.

[네이글 알고리즘 적용 후]

패킷을 보낼 때 고정 크기의 버퍼에 모아두고 버퍼에 어느정도 차면 그 때 보내고 다시 ACK가 오면 버퍼에 찬 데이터를 보내는 방법.

- 장점
    - 네트워크 혼잡 감소
    - 오버헤드 감소
- 단점
    - 지연시간 증가

## HTTP 멱등성이 무엇인지 설명해주세요.

HTTP 멱등성이란 하나의 요청이 아닌 여러번 동일한 요청을 보냈을 때 서버가 같은 상태를 가지는 것을 멱등성이라고 합니다.

### 멱등성을 가지는 메소드

GET: 안전한 메소드

HEAD: GET요청이 생성하는 응답의 헤더를 검색하는데 사용된다. 안전한 메소드

OPTIONS: 통신 옵션을 가져온다.안전한 메소드

PUT: 리소스를 완전히 다른 버전으로 대체한다.

DELETE: 리소스가 삭제되면 삭제 작업을 반복해도 시스템의 상태가 더 이상 변경되지 않는다.

### 멱등성을 가지지 않는 메소드

POST: 새로운 리소스를 생성하는데 사용되며 여러 POST요청은 여러 리소스를 생성하는 결과를 초래

PATCH: 필드를 특정 값으로 수정하는 것이라면 멱등성을 가지지만, 특정 필드의 값을 증가시키거나 해당 배열에 요소를 추가하는 것이라면 멱등성을 가지지 않는다.

멱등성이 중요한 이유?

1. 일관성
    1. 보통 반복되는 요청이 단일 요청과 동일한 효과를 갖도록 보장하는 것은 시스템 전반에 걸쳐 일관된 상태를 유지하는데 도움이된다.
2. 유지보수성
    1. 멱등성을 가진 HTTP 메서드로 api를 통신하는 부분에 있어서는 재시도를 처리할 때 사이드이펙트를 고려할 필요가 없기 때문에 이 부분을 잘 고려해서 설계한다면 유지보수성이 증가한다.

## XSS가 무엇인가요?

공격자가 웹사이트의 입력 필드에 악성 스크립트가 포함된 데이터를 입력하고 이를 웹 애플리케이션이 필터링하지 않을 경우 공격자의 악의적 스크립트로 인해 다른 사용자의 쿠키, 세션등이 탈취되어 피해가 발생하는 것

방어 기술

- 입력값 검증
- 출력값 처리
- 콘텐츠 보안 정책
- HttpOnly 쿠키 사용

## CSRF가 무엇인가요?

사용자가 의도하지 않은 요청을 특정 웹사이트에 보내도록 유도하는 공격.

사용자의 인증 정보를 악용해 권한 있는 요청을 위조하는 것이 핵심이다.

### 보안 방법

- 사용자 폼 마다 고유 토큰 발급하고 서버 검증
- 쿠키 옵션 중 sameSite=Strict로 타도메인에서 쿠키 전송을 막는 방법
- 민감한 요청은 한번 더 확인하는 UI를 쓰는 방법등이 있다.