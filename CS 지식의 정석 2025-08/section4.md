## 운영체제와 컴퓨터시스템의 구조

### 운영체제의 종류

운영체제는 앞단의 어떤 인터페이스를 두느냐에 따라 GUI와 CUI로 나뉜다.

### GUI

Graphical User Interface는 그래픽을 사용하여 컴퓨터와 상호작용하는 인터페이스

ex) windowOS, macOS 등

### CUI

Character User Interface는 상용자가 키보드만을 사용하여 문자를 기반으로 컴퓨터와 상호작용하는 인터페이스이다.

예전 OS인 MS-DOS가 대표적이다. 1994년 단종.

ex) ChatGPT

### 운영체제의 역할

운영체제의 커널이 담당합니다.

- CPU 스케줄링과 프로세스 상태관리
- 메모리관리
- 디스크 파일 관리
- I/O 디바이스 관리

### 운영체제의 구조 (굵은 글씨 부분만 해당)

Program

**Interface**

**System call**

**Kernel**

hardware

### 컴퓨터 시스템의 구조

- CPU: 인터럽트에 의해 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼
- DMA컨트롤러: CPU의 일을 보조하는 일꾼
- 메모리: 전자회로에서 데이터, 상태 등을 기록하는 장치 = 작업 공간
- 타이머: 특정 프로그램에 시간을 다는 역할. 무한 루프를 제한
- 디바이스 컨트롤러: IO디바이스들의 작은 CPU
- 로컬버퍼: 디바이스에 달려 있는 작은 메모리

### CPU

산술논리연산장치, 제어장치, 레지스터로 구성되어있는 장치. 인터럽트에 의해 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼.

### 산술논리연산장치(Arithmetic and Logical Unit)

덧셈, 뺄셈, 곱셈, 나눗셈 등 산술연산과 논리연산을 하는 회로장치를 말합니다.

### 제어장치

프로세스의 조작을 지시하며 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.

### 레지스터

CPU안에 있는 매우 빠른 임시 기억장치

## 인터럽트

‘운영체제는 인터럽트로 구동된다.’

인터럽트란 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말하며, 0으로 숫자를 나누는 산술 연산오류, 프로세스 오류 등으로 발생합니다.

또한 오류뿐만 아니라 키보드, 마우스 등 IO 디바이스를 사용할 때의 인터럽트, 우선순위가 높은 프로세스의 발생 등으로 발생합니다.

CPU는 메모리에 있는 명령어를 순차적으로 실행하는데 인트럽트가 발생되면 점프해서 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터(인터럽트 서비스 루틴, ISR)로 가서 인터럽트핸들러 함수가 실행되며 특정 명령어를 실행하게 됩니다. 이후 인터럽트가 종료되면 다시 순차적으로 실행되게 됩니다.

### 인터럽트의 종류

하드웨어 인터럽트, 소프트웨어 인터럽트 두 가지로 나뉜다.

- 하드웨어 인터럽트
    - IO 디바이스 등 하드웨어에서 발생하는 인터럽트. 예를 들어 마우스를 기반으로 버튼을 클릭할 때, 디스크에서 파일읽기, 쓰기 작업이 완료되었을 때 발동된다.
- 소프트웨어 인터럽트
    - 트랩(trap)이라고도 한다. 프로세스 오류, 프로세스의 종료, 시작 등을 기반으로 프로세스에서 발생하는 인터럽트이다. 하드웨어 인터럽트보다 우선순위가 높은 인터럽트이다.

## 시스템 콜과 modebit

### 시스템 콜

시스템 콜이란 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 이를 거쳐서 호출하도록 설계되어 있습니다.

프로세스 관리(생성, 삭제 등), 파일관리, 디바이스 관리, 시간 및 날짜 관련 시스템, 프로세스 간 통신 때 이를 통해 커널함수를 호출합니다.

예를 들어, 프로세스를 종료하는 kill()이라는 함수가 있습니다. 이 함수를 발동시키면 시스템콜을 거쳐 커널함수가 호출되게 됩니다.

### 시스템 콜의 과정

만약 유저프로그램이 I/O 요청을 위한 트랩을 발동했다고 하면 다음과 같은 과정이 발생한다.

1. 유저 프로그램이 I/O 요청 트랩발동
2. 올바른 I/O 요청인지 확인
3. 유저 모드가 시스템콜을 통해 커널모드로 변환
4. 이후 커널함수를 실행

### 커널 함수

커널 안에 있는 여러개의 함수

### 커널

운영체제의 핵심 부분이자 시스템콜을 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할

### 유저 모드

유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하는 모드

### 커널 모드

모든 컴퓨터 자원에 접근할 수 있는 모드

### modebit

시스템콜이 작동될 때 modebit을 기반으로 유저 모드와 커널 모드를 구분합니다. modebit은 1 또는 0의 값을 가지는 플래그 변수이며 1은 유저모드, 0은 커널모드를 가리킵니다.

### 시스템 콜의 장점

유저 프로그램은 시스템콜을 기반으로 커널과 분리가 된다. 즉, 유저프로그램은 복잡한 파일 시스템과 프로세스 생성 등에 대한 내부동작을 신경 쓸 필요가 없다. 또한, 운영체제의 관리하에 프로그램이 운영되므로 시스템의 안정성과 보안이 강화된다.

예를 들어, 공격자가 만든 카메라 앱 프로그램이 그냥 아무런 제약없이 커널에 접근할 수 있으면 공격자 마음대로 카메라를 켤 수 있다. 이런것을 방지하기 위해 유저 모드에서 시스템 콜로만 커널 모드에 진입할 수 있게 하나의 통로만 만든 것이다.

## 메모리계층

메모리 계층은 레지스터, 캐시, 주기억장치, 보조기억장치로 구성되어 있다.

- 레지스터: CPU 내의 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량 가장 작음
- 캐시: CPU내의 L1, L2 캐시를 지칭한다. 휘발성, 속도 빠름, 기억 용량 적음
- 주기억장치: RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량 보통
- 보조기억장치: HDD, SSD. 비휘발성, 속도 느림, 기억 용량 큼

### 계층이 존재하는 이유

- 더 빠른 접근과 처리속도가 증가
    - 우리는 보통 많이 쓰는 것을 다시 많이 씁니다. 이 때문에 특정 데이터에 많이 접근하게 되는데 좀 더 작은 캐시 메모리에 해당 데이터가 있다면 더 빠르게 해당 데이터에 접근이 가능합니다. 그로인해 처리속도도 증가하게 됩니다.
- 비용이 효율적 사용
    - 캐시메모리는 비싸고 램 등 아래로 갈수록 비용은 저렴해집니다. 계층이 있고 캐싱 때문에 비용을 좀 더 효율적으로 쓸 수 있습니다.
- 자원의 효율적 사용
    - 메모리 계층 구조는 자주 접근하는 데이터는 빠른 메모리에, 덜 접근하는 데이터는 느린 메모리에 저장하여 자원을 효율적으로 쓸 수 있습니다.

## 가상메모리, 페이지테이블, 스레싱

### 가상 메모리

virtual memory는 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자에게 매우 큰 메모리로 보이게 만드는 메모리 관리 기법입니다.

이는 그냥 커보이게만 하는게 아니라 그 안에 들어가있는 페이지 테이블, MMU, TLB, 페이지폴트 등이 어우러진 시스템을 통틀어서 말합니다.

*페이지: 가상 메모리를 사용하는 최소 크기 단위

*프레임: 실제 메모리를 사용하는 최소 크기 단위

### 페이지 테이블

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있는 페이지 테이블로 관리되며 이 때 속도 향상을 위해 캐싱계층인 TLB를 씁니다.

가상주소에서 바로 페이지테이블을 가는게 아니라 TLB에서 있는지를 확인하고 만약 없다면 페이지테이블로 가서 실제 주소를 가져옵니다.

![image.png](attachment:22b550ad-62e0-4358-b23c-d41088e113c4:image.png)

### 프로세스 A와 프로세스 B가 실행 및 종료 시의 메모리 할당 과정

예를 들어, 프로세스A와 프로세스B가 실행되었을 때 메모리 할당 등을 알아보면서 가상메모리와 물리메모리를 다시 살펴보자

- 가상 메모리와 물리 메모리

각 프로세스는 자신만의 주소공간을 갖고 있습니다.

가상 주소는 프로세스가 메모리에 접근할 때 사용하는 주소입니다.

예를들어, 프로세스A와 B가 각각 0x0000과 0x1000의 가상 주소를 갖고 있다고 생각하자.

물리 메모리는 실제로 존재하는 RAM의 주소공간이며 가상 주소는 실제로 물리 메모리의 주소와 직접적인 관계가 없다.

이를 매핑해주는 페이지테이블이 있고 이걸 기반으로 CPU의 MMU이 가상주소를 물리주소로 변환합니다.

- 프로세스의 종료와 재실행

프로세스 A와 B가 종료되면, 그들의 가상 주소 공간과 페이지 테이블은 해제됩니다.

A와 B가 다시 실행되면, 운영 체제는 새로운 가상 주소 공간을 할당합니다.

하지만 이 가상 주소 공간이 이전과 동일하지 않을 수 있습니다. 운영체제는 가상 주소를 자유롭게 사용할 수 있습니다.

또한 중요한 점은 가상주소가 동일하더라도, 실제 물리 메모리 주소는 다를 수 있습니다.

각 프로세스의 별도의 페이지 테이블에 의해 서로 다른 물리 메모리 영역에 매핑되며 가상 주소는 해당 프로세스 내에서만 유효한 값이기 때문에 충돌이 발생하지 않습니다.



### 페이지 폴트

가상메모리는 작은 메모리를 매우 큰 메모리로 보이게끔 하는 것이기 때문에 참조하려는 메모리 영역이 상대적으로 작은 실제 메모리에 없을 수도 있다. 이 때 페이지폴트가 일어난다.

운영체제는 전체 프로세스의 메모리 내용을 디스크로부터 한 번에 RAM에 올리지 않는다. 처음에 필요한 부분들만 효율적으로 올린다.

### 페이지 폴트 이후 과정

1. 페이지 폴트 이후 OS에게 트랩을 전송합니다.  OS는 먼저 페이지 폴트가 유효한 접근인지 점검합니다.
2. OS는 물리 메모리에서 빈 프레임이 있는지 확인하고 다음의 과정이 일어납니다.
    1. 빈프레임이 있는 경우
        1. 디스크에서 필요한 페이지를 바로 메모리로 가져와 적재합니다.(swap-in)이때 기존 페이지를 내보내는 작업은 없습니다.
    2. 빈 프레임이 없는 경우
        1. 페이지 교체 알고리즘을 수행하여 기존의 한 페이지를 선택합니다.
           선택한 페이지를 디스크로 내보냅니다.(swap-out)
           빈 프레임을 확보 후 필요한 페이지를 디스크에서 메모리로 가져옵니다(swap-in)

### 스레싱

스레싱은 실제 프로세스 실행보다 스와핑 작업에 대부분의 시간이 소요되는 현상을 말합니다. 페이지 폴트가 빈번하게 발생하면, 필요한 데이터를 디스크에서 메모리로 불러오는 과정이 잦아지고 이로 인해 스와핑이 과도하게 일어납니다.

그 결과, CPU는 실제 연산을 수행하기보다 스와핑 대기 상태에 머무르게 되어 전체적인 CPU 이용률이 낮아집니다.

이러한 상황에서 운영체제는 CPU의 낮은 사용률을 보완하고자 추가 프로세스를 메모리에 적재하게 되는데, 이는 이미 부족한 메모리 자원을 더 압박하게 됩니다.

→ 시스템 전체의 성능이 급격히 저하되는 스레싱 현상.

이를 하드웨어적으로 해결하는 방법으로는 메모리를 늘리거나 HDD를 SSD로 바꾸는 방법도 있고 운영체제에서 해결하는 방법은 작업세트와 PFF가 있다.

### 작업세트

작업 세트(working set)는 프로세스의 과거 사용이력을 기반으로 많이 사용하는 페이지집합을 만들어 한꺼번에 미리 메모리에 로드하는 것

→ 페이지 폴트 발생이 낮아짐

### PFF

각 프로세스의 페이지 폴트 발생 빈도를 모니터링하여, 메모리 프레임의 할당량을 동적으로 조절하는 방법

### 가상 메모리의 장점

- 메모리의 효율적 사용
    - 프로그램 실행 시 모든 데이터를 한꺼번에 메모리에 적재하지 않고, 실제로 필요한 시점에 해당 메모리 페이지만 동적으로 불러온다. 이 덕분에 제한된 ram 내에서도 대용량 프로그램을 효율적으로 실행할 수 있으며, 이러한 방식을 Deman paging이라고 한다.
- 메모리 과잉 할당
    - 실제 RAM보다 훨씬 큰 주소 공간을 사용할 수 있어서 메모리 자원을 최대한 효율적으로 배분할 수 있다.
- 프로세스 간 메모리 보호
    - 가상 주소 공간의 독립성을 통해, 프로세스 간 물리 메모리 참조를 할 수 없게 보장한다.
- 메모리 접근 제어
    - 페이지 각각의 읽기, 쓰기, 실행 권한을 설정할 수 있어 권한 없는 접근 시도를 감지하고 차단할 수 있다.

## 페이지 히트와 페이지 미스

- 페이지 히트
    - 페이지 히트는 프로세스가 요청한 해당 페이지가 이미 메모리에 적재되어 있어 바로 접근할 수 있는 상황
- 페이지 미스
    - 페이지 미스는 프로세스가 요청한 해당 페이지가 메모리에 없는 상황
- 페이지 미스와 페이지 폴트
    - 모든 페이지 폴트는 페이지 미스로 인해 발생하지만, 모든 페이지 미스가 페이지 폴트로 이어지는 것은 아니다.

  다음의 경우는 페이지 미스가 나지만 페이지 폴트로 이어지지 않는다.

    1. 접근 권한 오류
       해당 페이지에 대한 접근 권한이 없거나 잘못된 접근이 시도되었을 경우 운영체제는 이를 오류로 처리하고 해당 요청을 거부한다.
       이 경우 페이지 미스는 발생하지만 실제로 페이지를 메모리로 로드하지 않고, 오류를 발생시키므로 페이지 폴트로 이어지지 않는다.
    2. 성능 최적화를 위해 미리 로드할 때의 페이지 미스
       페이지를 실제로 사용하기 전에 미리 요청(프리페칭)하는 최적화 기법을 사용할 경우, 이 때 실제 데이터 사용 전에 다른 데이터로 덮어쓰게 될 경우 페이지 미스는 발생하지만, 사용되지 않아 페이지 폴트로는 발전하지 않는다.

## 페이지 교체 알고리즘1: 오프라인 알고리즘

스와핑이 일어날 때 페이지 교체 알고리즘에 의해 페이지가 교체된다.

오프라인 알고리즘은 페이지교체 알고리즘 중 가장 좋은 알고리즘이라고 일컫는 알고리즘이며 이는
1. 더 이상 참조되지 않거나 2. 가장 늦게 다시 참조되는 페이지와 지금 요청된 페이지를 바꾸는 알고리즘이다.

LFD 알고리즘은 사실상 구현할 수 없는 알고리즘이다.

앞으로 사용될 페이지를 예측할 수 없기 때문이다.(미래 순서 기반)

그래서, upper bound 역할로 성능 측정 비교에 사용될 수 있다.

## 페이지 교체알고리즘2: FIFO, LRU, NUR, LFU

- FIFO

Page reference 1, 3, 0, 3, 5, 6, 3

1(miss)→3(miss)→0(miss)→3(hit)→5(miss)→6(miss)→3(miss)

|  |  | 0 | 0 | 0 | 0 | 3 |
| --- | --- | --- | --- | --- | --- | --- |
|  | 3 | 3 | 3 | 3 | 6 | 6 |
| 1 | 1 | 1 | 1 | 5 | 5 | 5 |

먼저 들어온 것을 miss 시 먼저 내보낸다.

- LRU(Least Recently Used)

참조가 오래된 페이지를 바꾼다.

이를 위해 각 페이지마다 최근 사용한 횟수를 나타내는 자료구조를 따로 만들어야 할 수도 있다.

Page reference 7, 0, 1, 2, 0, 3, 0, 4

| 7 | 7 | 3 | 3 | 3 |
| --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 4 |
| 2 | 2 | 2 | 2 | 2 |

- NUR(Not Used Recently), NRU(Not Recently Used)

LRU에서 발전한 알고리즘

일명 clock 알고리즘이라고 하며, 먼저 0과 1을 가진 비트를 둡니다. 1은 최근에 참조되었고 0은 참조되지 않음을 의미합니다. 만약 한 바퀴 도는 동안 사용되지 않으면 0이됩니다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 페이지를 교체하고, 해당 부분을 1로 바꾸는 알고리즘이다.

- LFU(Least Frequently Used)

가장 참조 횟수가 적은 페이지를 교체하는 알고리즘

Page reference 0, 1, 2, 0, 0, 1, 2, 3

| 0 | 0 | 0 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 1 | 1 | 3 |
| 2 | 2 | 2 | 2 | 2 | 2 |

참조 횟수가 적은 1과 2 중 골라 스와핑을 진행한다.

## 프로세스와 스레드의 차이

- 프로세스
    - 메모리에 올라와 실행되고 있는 프로그램, task와 같은 의미로 쓰인다.
- 스레드
    - 프로세스 내 작업의 흐름을 지칭한다.

- 프로세스와 스레드의 차이
    - 프로세스는 코드, 데이터, 스택, 힙 메모리 영역을 기반으로 작업하는 반면 스레드는 프로세스 내의 스택 메모리를 제외한 다른 메모리 영역을 프로세스 내의 다른 스레드들과 공유하기 때문에 메모리적 이점이 있다.
    - 프로세스는 다른 프로세스와 격리되어 있기 때문에 서로 통신을 하기 위해서는 IPC를 사용해야 하지만 스레드는 다른 스레드와 격리되어 있지 않으므로 그냥 통신할 수 있으므로 프로세스보다 더 빠르다.
    - 프로세스는 다른 프로세스에 영향 전파가 되지 않지만 한 프로세스 안의 여러 스레드는 영향을 주고받는다.
    - 프로세스는 생성과 종료에 더 많은 시간이 들며 스레드는 더 적은 시간이 든다.

## 프로그램의 컴파일 과정

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는 파일이 된 것을 의미한다.

1. 전처리
    1. 소스코드의 주석제거, #include 등 헤더파일을 병합하고 매크로를 치환합니다.
2. 컴파일러
    1. 오류처리, 코드최적화 작업을 하여 어셈블리어로 변환한다.
3. 어셈블러
    1. 어셈블리어는 목적코드로 변환된다.
4. 링커
    1. 프로그램 내에 있는 라이브러리 함수 등과 결합해 실행 파일(.exe, .out)이 만들어진다.

## 프로세스의 메모리 구조

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당합니다.

위에서부터 스택, 힙, 데이터영역, 코드 영역으로 나눠집니다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당됩니다.

운영체제가 프로그램을 메모리에 올려 프로세스를 만들 때

Stack-heap-data-code 구조로 할당한다.

- 스택: 지역변수, 매개변수, 함수가 저장되고 동적인 특징이 있다. 함수가 함수를 호출하는 등에 따라 런타임시에도 크기가 변경된다.(동적인 특징)
- 힙: 힙은 동적 할당을 할 때 사용되고 런타임 시 크기가 결정된다
- 데이터 영역: BSS 영역과 Data영역으로 나뉘고 정적할당에 관한 부분을 담당한다.
- 코드영역: 소스코드가 들어간다.(정적 특징)

### 정적 할당

Bss Segment는 전역변수, static, const로 선언되어있는 변수 중 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 메모리 영역에 할당된다.

Data Segment는 전역변수, static, const로 선언된 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 저장된다.

### 동적 할당

Stack + Heap

Stack: 콜스택

Heap: 동적으로 관리되는 자료구조인 경우 Heap영역을 사용한다.(ex. 벡터)

## PCB와 컨텍스트 스위칭

PCB(Process Control Block)는 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터블록이며 커널 스택에 저장되며 각 프로세스가 생성될때 마다 고유의 PCB가 생성되고 프로세스 종료 시 제거된다.

*유저 메모리 - 유저모드

*커널 메모리 - 커널모드

PCB는 커널스택에 저장된다.

### PCB의 구조

- Process State : 대기중, 실행 중 등 프로세스의 상태
- PID: 각 프로세스의 고유 식별 번호
- 프로그램 카운터(PC): 이 프로세스에 대해 다음 실행된 명령어 주소에 대한 포인터
- 레지스터: 레지스터 관련 정보
- 메모리 제한: 프로세스의 메모리 관련정보
- 열린 파일 정보: 프로세스를 위해 열린 파일 정보

### 컨텍스트 스위칭(프로세스 뿐 아니라 스레드도 가능)

PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정이다.

이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.

- 컨텍스트 스위칭 비용
    - 유휴시간 발생
    - 캐시미스: 메모리 주소가 그대로 있으면 잘못된 주소 반환이 생기므로 캐시클리어 과정이 무조건 일어나게 되고 이 때문에 캐시미스가 발생한다.
    - 오버헤드

- 스레드에서의 컨텍스트 스위칭
    - 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용이 더 적고 시간도 더 적게 걸린다는 장점이 있다.

## 프로세스의 상태

- 생성 상태
    - 생성 상태는 프로세스가 생성된 상태를 의미
    - fork() 부모가 주소공간을 그대로 복사하여 새로운 자식 프로세스를 생성
    - exec() 새롭게 프로세스를 생성하는 함수
- 대기 상태
    - 대기 상태(ready)는 처음 프로세스가 생성된 이후 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 준비큐에 들어가서 대기중인 상태를 말한다.
- 대기 중단 상태
    - 준비큐가 꽉 찬 상태로 메모리 부족으로 일시 중단된 상태
- 실행 상태
    - running은 CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미. CPU burst가 일어났다고도 표현
- 중단 상태
    - blocked는 어떤 이벤트가 발생 후 인터럽트 등으로인해 기다리며 프로세스가 차단된 상태.
- 일시 중단 상태
    - blocked suspended 는 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려 했지만 메모리 부족으로 일시 중단된 상태
- 종료 상태
    - 프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하며 PCB가 삭제되는 상태

## 멀티프로세싱과 멀티스레딩

- 멀티프로세싱
    - 동시에 두 가지 이상의 일을 수행할 수 있는 것. 특정 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스에 영향을 미치지 않으며 격리성과 신뢰성이 높은 강점
- 멀티스레딩
    - 프로세스 내 작업을 멀티스레드로 처리하는 방법. 한 스레드에 문제가 생기면 다른 스레드에도 영향을 줄 수 있는 단점

## IPC(Inter Process Communication)

- 공유 메모리
    - 여러 프로세스가 통신할 수 있도록 메모리를 공유하는 것.
    - IPC중 가장 빠른 통신방법
- 파일
    - 디스크에 저장된 데이터를 기반으로 통신하는 것을 의미
    - 요즘은 잘 쓰이지 않음
- 소켓
    - 네트워크 인터페이스(TCP, UDP, HTTP 등)을 기반으로 통신하는 것을 의미
- 파이프
    - 파이프는 익명파이프, 명명 파이프로 나뉜다.
        - 익명 파이프
            - 프로세스 사이에 FIFO 기반의 통신채널로 통신하는 것(단방향 통신)
            - 부모, 자식 프로세스간에만 사용 가능
        - 명명 파이프
            - 익명 파이프에서 확장된 개념
            - 부모, 자식 뿐 아니라 다른 네트워크 상에서도 통신할 수 있다.
- 메세지 큐
    - 메시지를 큐 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 것.
        1. 프로세스가 메시지를 보내거나 받기 전에 큐를 초기화한다
        2. 보내는 프로세스의 메시지는 큐에 복사되어 받는 프로세스에 전달된다.
    - c언어로 구축된 예제가 많다.

## 공유자원과 경쟁상태 그리고 임계영역

- 공유 자원
    - shared resource란 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미
- 경쟁 상태
    - 경쟁 상태는 이 공유 자원들이 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며동시에 접근을 시도할 때의 타이밍이 예상되는 결과 값에 영향을 줄 수 있는 상태를 의미한다.
- 임계 영역(코드 영역)
    - 임계영역(critical section)은 둘 이상의 프로세스 또는 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드영역을 말합니다. 이 영역은 한 번에 둘 이상의 프로세스나 스레드가 들어갈 수 없게 설계됩니다.

### 경쟁 상태 관리의 중요성

경쟁 상태를 잘 해결하지 못하면 데이터 정합성, 데이터 무결성을 지키지 못할 수 있다.

- 정합성: 예상되는 데이터값이 다른 것
- 무결성: 데이터가 어떤 규칙을 위배하면 안되는 것

## 뮤텍스, 세마포어, 모니터

경쟁상태를 해결하는 대표적인 방법으로 뮤텍스, 세마포어, 모니터가 있으며 이들은 상호배제, 한정대기, 진행의 융통성의 조건을 만족시키며 경쟁상태를 해결한다.

(프로세스와 스레드 모두에 적용되는 기법)

- 상호 배제: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음
- 한정 대기: 특정 프로세스가 임계영역 진입을 요청한 후 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것을 말하며 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하는 것을 방지함
- 진행의 융통성: 만약 어떠한 프로세스도 임계영역을 사용하지 않는다면 임계영역의 외부 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는 것을 의미함

### 뮤텍스

공유자원을 lock()을 통해 잠금하고 unlock()을 통해 잠금해제를 하여 객체 lock을 기반으로 경쟁상태를 해결.

### 세마포어

세마포어는 일반화된 뮤텍스를 의미한다. 간단한 정수 S와 두가지 함수 wait()및 signal()로 공유 자원에 대한 접근을 처리한다. 이를 통해 여러 프로세스가 동시에 임계영역에 접근할 수 있다.

- S는 현재 쓸 수 있는 공유자원의 수
- wait() 는 S를 1씩 감소시킨다. 감소시키다가 S가 음수가 되면 공유자원을 쓸 수 없기 때문에 프로세스는 차단되고 대기열에 프로세스를 집어넣습니다.
- signal()은 S를 1씩 증가시킨다. 공유자원을 프로세스가 다 쓴 상태를 말한다. 이 때 만약 S가 0이하라면 대기열에 있던 프로세스가 동작하게된다.

ex) 5명의 사용자만이 로그인하여 들어갈 수 있는 게임

mutex-잠금기반, semaphore-신호기반

### 모니터

모니터는 둘 이상의 스레드나 프로세스가 공유자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체.

이를 통해 공유자원에 대한 작업들을 순차적으로 처리.

모니터와 세마포어 차이?

모니터는 세마포어보다 구현하기 쉬우며 한번에 하나의 프로세스만 공유자원에 접근할 수 있다.

때문에 상호배제가 자동이다. 인터페이스를 기반으로 구축된다.

세마포어는 모니터보다 구현하기 어려우며 한번에 여러개의 프로세스가 공유자원에 접근할 수 있다. 이 때문에 상호배제를 명시적으로 구현해야 한다. 또한 정수변수를 기반으로 구축된다.

## 교착상태(Deadlock)

두 개이상의 프로세스가 서로가 가진 자원을 기다리며 중단된 상태

교착 상태의 원인

교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.

- 상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉, 다른 프로세스의 접근이 불가능하다.
- 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
- 환형 대기: 프로세스A는 프로세스B의 자원을 요구하고, 프로세스 B는 프로세스A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황

### 교착상태의 해결 방법

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 교착 상태 가능성이 없을 때만 자원 할당, 프로세스당 요청할 자원의 최대치를 통해 자원 할당가능 여부를 파악하는 ‘은행원 알고리즘’을 쓴다.
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 하나씩 지운다.
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다. 현대 운영체제가 택한 방법.

### 은행원 알고리즘

은행원 알고리즘은 교착상태를 회피하는 알고리즘으로 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘

2차원 배열 3개와 1차원 배열 2개를 사용한다.

- 은행원 알고리즘의 단점
    - 프로세스가 시스템에 들어갈 때 필요한 최대 자원 수를 예측해야 하는데 이를 예측하기가 쉽지 않고 해당 알고리즘에 대한 자원소모량이 증가하게 되며 프로그램의 수는 고정되어 있지 않고 항상 변하기 때문에 쓰기가 어려운 단점이 있다.

## CPU 스케줄링 알고리즘1 비선점형(FCFS, SJF, 우선순위)

cpu가 어떤 프로세스를 선택할 것인지 스케줄링알고리즘을 통해 선택되며 효율적으로 선택하는게 중요하다. 여기서 효율적이란 것은 다음과 같은 사항을 만족시킬 때 효율적이다라고 한다.

1. CPU 사용률이 높은가?
2. 단위 시간당 작업을 마친 프로세스의 수가 높은가?
3. 작업을 요청한 프로세스가 작업을 시작하기 전 대기하는 시간은 짧은가?

방식은 비선점형과 선점형으로 나뉜다.

비선점형은 non-preemptive. 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않는다. 따라서 컨텍스트 스위칭에 대한 부하가 적다.

### FCFS

FirstComeFirstServed는 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘.

길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect)이 발생하는 단점이 있다.

### SJF

Shortest Job First 실행시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.

긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 일어날 수 있고 평균 대기 시간이 가장 짧다.

실제로는 실행 시간을 알 수 없기 때문에 과거 실행했던 시간을 토대로 추측해서 사용한다.

### 우선순위

SJF에서 오래된 작업일 수록 우선순위를 높이는 방법(aging)을 통해 단점을 보완한 알고리즘.

여기서 우선순위는 작업의 시간, 메모리 요구사항, 열린 파일 수, 평균 CPU 사용량 등을 고려하여 설정된다.

## CPU 스케줄링 알고리즘2 - 선점형(라운드로빈, SRF, 다단계큐)

현대 운영체제가 쓰는 방식. preemptive

### 라운드 로빈

현대 컴퓨터가 쓰는 단순한 선점형 알고리즘.

각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘.

예를 들어, q시간이 할당되고 N 개의 프로세스가 있다면 (N-1)*q 시간 후 다시 자기 차례가 돌아옵니다.

일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이있다.

또한, 이 알고리즘은 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰인다.

### SRF

SJF를 선점형 알고리즘으로 변경한 것.

### 다단계 큐

우선순위에 따른 준비 큐를 여러개 사용하고, 큐마다 라운드 로빈이나 FCFS등 다른 스케줄링 알고리즘을 적용한 것을 말한다. 큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있다. 우선순위가 높은 큐부터 처리되므로 낮은 큐의 프로세스가 처리되지 않는 기아현상이 발생할 수도 있다.

## 캐시 1 - 캐시히트와 캐시미스 그리고 실습

데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터접근시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다.

캐시의 예는 CPU 레지스터가 대표적인데 CPU가 메모리로부터 데이터를 가져올 때의 시간이 너무나 크기 때문에 그 중간에 레지스터 계층을 둬서 속도차이를 해결합니다.

캐시히트란 캐시에서 원하는 데이터를 찾은 것을 말하며 캐시미스는 캐시에서 원하는 데이터를 찾지 못한 것을 말한다. 앞의 예시 같은 경우는 캐시미스가 일어나면 메모리로 가서 원하는 데이터를 레지스터에 등록하게 된다.

### 캐시- 지역성의 원리

캐시를 설정할 때는 자주 사용되는 데이터를 기반으로 설정해야 한다. 이 때 지역성을 기반으로 설정되는데 지역성은 시간 지역성과 공간 지역성으로 나뉜다.

- 시간 지역성
    - 시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성을 말한다.
- 공간 지역성
    - 공간 지역성은 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.

## 캐시 2 - 캐시 매핑: 직접매핑, 연관매핑, 집합 - 연관매핑

캐시의 크기는 메모리보다 항상 작기 때문에 효율적으로 매핑하는 것이 중요하며 매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다.

### 직접 매핑

메모리의 특정 블록은 특정 캐시 라인에만 매핑할 수 있는 것을 말한다.

## 메모리 할당 1 - 연속할당: 고정 분할과 가변분할

프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데 이는 연속할당과 불연속 할당으로 나뉩니다.

- 연속 할당(contiguous memory allocation) 은 메모리에 ‘연속적으로’ 공간을 할당하는 것을 말합니다. 사용 가능한 모든 메모리 공간이 같은 위치에 함께 있습니다. 즉, 메모리 파티션이 전체 메모리 공간에서 여기저기서 분산되어있지 않습니다. 이는 고정분할방식과 가변분할방식이 있습니다.

### 고정분할방식

고정분할방식(fixed partition allocation)은 메모리를 미리 같은 크기로 분할해서 할당하는 방법. 이는 내부단편화(내부의 남는 영역)가 발생한다.

*내부단편화: 내부단편화란 프로그램이 필요한 공간보다 더 많은 메모리가 할당되어 내부적으로 조각이 많이 생기는 것을 의미한다. 이를 통해 추후에 프로그램에 필요한 메모리를 할당하지 못하는 현상이 일어난다.

### 가변분할방식

프로그램에 필요한만큼  동적으로 할당하는 방식. 이는 내부단편화가 발생하지 않고 외부단편화가 발생할 수 있다.

*외부단편화: 외부의 조각들이 큰 프로그램이 왔을 때 메모리를 할당하지 못하는 현상 발생

가변분할방식은 최초적합, 최적적합, 최악적합이 있다.

- 최초적합(first fit): 위쪽이나 아래쪽부터 시작해 홀을 찾으면 바로 할당
- 최적적합(best fit): 필요한 메모리 크기 이상인 공간 중 가장 작은 홀부터 할당
- 최악적합(worst fit): 프로세스의 크기와 가장 많이 차이가 나는 홀(메모리 공간)에 할당

*hole: 메모리 공간

## 메모리 할당 2 - 불연속할당: 페이징, 세그멘테이션, 페이지드 세그멘테이션

- 페이징
    - memory paging은 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당합니다. 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환을 페이지별로 해야하기 때문에 주소변환이 복잡해지는 단점이 있습니다.
      내부 단편화가 생길 수 있다.
- 세그멘테이션
    - memory segmentation은 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식입니다. 프로세스는 코드, 데이터, 스택, 힙으로 나누어져서 메모리가 할당되는데 코드와 데이터 또는 코드와 스택 등으로 나눌 수도 있으며 함수 단위로 나눌 수도 있음을 의미합니다. 공유와 보안측면에서 좋지만 홀 크기가 균일하지 않게 됩니다. 내부단편화가 해결될 수 있지만 외부단편화가 일어날 수 있습니다.
- 페이지드 세그멘테이션
    - 세그멘테이션으로 나누되 해당 세그먼테이션을 동일한 크기의 페이지로 나누는 방법

## LFD 알고리즘이 왜 최고의 페이지 교체 알고리즘인가요?

오프라인 알고리즘(Longest Forward Distance)가 가장 최적의 알고리즘이라고 했었습니다.

메모리 스왑을 하고 안하고를 반반 확률로 가져갈 수 있기 때문에 타 알고리즘과 대비하여 효율적임.

## convoy effect와 starvation의 차이?

- convoy effect
    - 몇개의 시간이 오래 걸리는 프로세스로 인해 다른 프로세스의 실행이 느려지고 평균 대기 시간이 길어지며 결과적으로 전체적인 프로세스의 성능을 저하시키는 현상. FCFS 알고리즘을 사용할때 나타날 수도 있는 현상입니다.

- starvation
    - 기아는 어떤 프로세스가 ‘무한대’ 대기하며 CPU소유권을 얻을 수 없음을 의미합니다. SJF 알고리즘을 사용할 때 나타날 수도 있는 현상입니다. 우선순위가 자꾸 밀려져서 해당 프로세스가 아예 실행이 되지 않습니다. 이를 극복하기 위한 한 가지 방법은 aging을 통해 우선순위를 높이는 방법입니다. 실행되지 않은 프로세스면 시간이 지나가면서 우선순위를 높여 실행되게 합니다.

## busy_wait란 무엇인가요?

busy wait은 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술

busy wait은 운영체제에서 프로세스가 공유자원에 동시에 접근하는 것을 방지하는 상호배제를 달성하는데 사용됩니다. busy_wait 상태에서는 우선순위에 따라 작업을 바꿀수 없기 때문에 우선 순위가 높은 작업을 완료해야 할 때 비효율적이며 대기시간이 많이 걸릴 경우 계속해서 기다리는데 CPU자원을 쓰기 떄문에 자원낭비가 심하다는 단점이 있습니다.

## 운영체제와 펌웨어의 차이점?

1. 펌웨어는 보통 ROM이라는 비휘발성 메모리를 하나 쓰는 반면 운영체제는 휘발성, 비휘발성 메모리를 계층화해서 씁니다.
2. 펌웨어는 자유로이 프로그램을 설치할 수 없으며 미리 설치해 놓은 프로그램을 기반으로 업데이트가 일어납니다. ROM에 해당 소프트웨어를 지우고 덮어쓰고 쓰면서 업데이트가 일어납니다. 운영체제는 정기적으로 업데이트가 되며 운영체제 위에 프로그램을 자유로이 설치할 수 있습니다.
3. 펌웨어의 종류로는 키보드, 세탁기안에 들어가있는 소프트웨어라고 할 수 있으며 운영체제의 종류로는 MacOS, windowOS가 대표적입니다.